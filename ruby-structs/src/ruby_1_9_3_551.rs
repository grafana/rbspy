/* automatically generated by rust-bindgen 0.63.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type __clockid_t = ::std::os::raw::c_int;
pub type clockid_t = __clockid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [usize; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
impl ::std::fmt::Debug for __pthread_cond_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__pthread_cond_s__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
impl ::std::fmt::Debug for __pthread_cond_s__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__pthread_cond_s__bindgen_ty_2 {{ union }}")
    }
}
impl ::std::fmt::Debug for __pthread_cond_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "__pthread_cond_s {{ __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?}, __g_refs: {:?}, __g_size: {:?}, __g1_orig_size: {:?}, __wrefs: {:?}, __g_signals: {:?} }}" , self . __bindgen_anon_1 , self . __bindgen_anon_2 , self . __g_refs , self . __g_size , self . __g1_orig_size , self . __wrefs , self . __g_signals)
    }
}
pub type pthread_t = usize;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
impl ::std::fmt::Debug for pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutex_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
impl ::std::fmt::Debug for pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_cond_t {{ union }}")
    }
}
pub type VALUE = usize;
pub type ID = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBasic {
    pub flags: VALUE,
    pub klass: VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString {
    pub basic: RBasic,
    pub as_: RString__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1 {
    pub heap: RString__bindgen_ty_1__bindgen_ty_1,
    pub ary: [::std::os::raw::c_char; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_long,
    pub ptr: *mut ::std::os::raw::c_char,
    pub aux: RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub capa: ::std::os::raw::c_long,
    pub shared: VALUE,
}
impl ::std::fmt::Debug for RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
impl ::std::fmt::Debug for RString__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RString__bindgen_ty_1__bindgen_ty_1 {{ len: {:?}, ptr: {:?}, aux: {:?} }}",
            self.len, self.ptr, self.aux
        )
    }
}
impl ::std::fmt::Debug for RString__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RString__bindgen_ty_1 {{ union }}")
    }
}
impl ::std::fmt::Debug for RString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RString {{ basic: {:?}, as: {:?} }}",
            self.basic, self.as_
        )
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray {
    pub basic: RBasic,
    pub as_: RArray__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1 {
    pub heap: RArray__bindgen_ty_1__bindgen_ty_1,
    pub ary: [VALUE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_long,
    pub aux: RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub ptr: *mut VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub capa: ::std::os::raw::c_long,
    pub shared: VALUE,
}
impl ::std::fmt::Debug for RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
impl ::std::fmt::Debug for RArray__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RArray__bindgen_ty_1__bindgen_ty_1 {{ len: {:?}, aux: {:?}, ptr: {:?} }}",
            self.len, self.aux, self.ptr
        )
    }
}
impl ::std::fmt::Debug for RArray__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RArray__bindgen_ty_1 {{ union }}")
    }
}
impl ::std::fmt::Debug for RArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RArray {{ basic: {:?}, as: {:?} }}",
            self.basic, self.as_
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_global_variable {
    _unused: [u8; 0],
}
pub type st_data_t = usize;
pub type st_index_t = st_data_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_hash_type {
    pub compare: ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>,
    pub hash: ::std::option::Option<unsafe extern "C" fn() -> st_index_t>,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table {
    pub type_: *const st_hash_type,
    pub num_bins: st_index_t,
    pub _bitfield_align_1: [u64; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub bins: *mut *mut st_table_entry,
    pub head: *mut st_table_entry,
    pub tail: *mut st_table_entry,
}
impl st_table {
    #[inline]
    pub fn entries_packed(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_entries_packed(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn num_entries(&self) -> st_index_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 63u8) as usize) }
    }
    #[inline]
    pub fn set_num_entries(&mut self, val: st_index_t) {
        unsafe {
            let val: usize = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 63u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        entries_packed: ::std::os::raw::c_uint,
        num_entries: st_index_t,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let entries_packed: u32 = unsafe { ::std::mem::transmute(entries_packed) };
            entries_packed as u64
        });
        __bindgen_bitfield_unit.set(1usize, 63u8, {
            let num_entries: usize = unsafe { ::std::mem::transmute(num_entries) };
            num_entries as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rb_unblock_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type rb_event_flag_t = ::std::os::raw::c_uint;
pub type rb_event_hook_func_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: rb_event_flag_t, data: VALUE, arg2: VALUE, arg3: ID, klass: VALUE),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_event_hook_struct {
    pub flag: rb_event_flag_t,
    pub func: rb_event_hook_func_t,
    pub data: VALUE,
    pub next: *mut rb_event_hook_struct,
}
pub type rb_event_hook_t = rb_event_hook_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RNode {
    pub flags: VALUE,
    pub nd_reserved: VALUE,
    pub u1: RNode__bindgen_ty_1,
    pub u2: RNode__bindgen_ty_2,
    pub u3: RNode__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RNode__bindgen_ty_1 {
    pub node: *mut RNode,
    pub id: ID,
    pub value: VALUE,
    pub cfunc: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
    pub tbl: *mut ID,
}
impl ::std::fmt::Debug for RNode__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RNode__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RNode__bindgen_ty_2 {
    pub node: *mut RNode,
    pub id: ID,
    pub argc: ::std::os::raw::c_long,
    pub value: VALUE,
}
impl ::std::fmt::Debug for RNode__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RNode__bindgen_ty_2 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RNode__bindgen_ty_3 {
    pub node: *mut RNode,
    pub id: ID,
    pub state: ::std::os::raw::c_long,
    pub entry: *mut rb_global_entry,
    pub cnt: ::std::os::raw::c_long,
    pub value: VALUE,
}
impl ::std::fmt::Debug for RNode__bindgen_ty_3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RNode__bindgen_ty_3 {{ union }}")
    }
}
impl ::std::fmt::Debug for RNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RNode {{ flags: {:?}, nd_reserved: {:?}, u1: {:?}, u2: {:?}, u3: {:?} }}",
            self.flags, self.nd_reserved, self.u1, self.u2, self.u3
        )
    }
}
pub type NODE = RNode;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_global_entry {
    pub var: *mut rb_global_variable,
    pub id: ID,
}
pub const ruby_method_ids_tUPLUS: ruby_method_ids = 321;
pub const ruby_method_ids_tUMINUS: ruby_method_ids = 322;
pub const ruby_method_ids_tPOW: ruby_method_ids = 323;
pub const ruby_method_ids_tCMP: ruby_method_ids = 324;
pub const ruby_method_ids_tEQ: ruby_method_ids = 325;
pub const ruby_method_ids_tEQQ: ruby_method_ids = 326;
pub const ruby_method_ids_tNEQ: ruby_method_ids = 327;
pub const ruby_method_ids_tGEQ: ruby_method_ids = 328;
pub const ruby_method_ids_tLEQ: ruby_method_ids = 329;
pub const ruby_method_ids_tANDOP: ruby_method_ids = 330;
pub const ruby_method_ids_tOROP: ruby_method_ids = 331;
pub const ruby_method_ids_tMATCH: ruby_method_ids = 332;
pub const ruby_method_ids_tNMATCH: ruby_method_ids = 333;
pub const ruby_method_ids_tDOT2: ruby_method_ids = 334;
pub const ruby_method_ids_tDOT3: ruby_method_ids = 335;
pub const ruby_method_ids_tAREF: ruby_method_ids = 336;
pub const ruby_method_ids_tASET: ruby_method_ids = 337;
pub const ruby_method_ids_tLSHFT: ruby_method_ids = 338;
pub const ruby_method_ids_tRSHFT: ruby_method_ids = 339;
pub const ruby_method_ids_tLAMBDA: ruby_method_ids = 352;
pub const ruby_method_ids_idNULL: ruby_method_ids = 365;
pub const ruby_method_ids_idRespond_to: ruby_method_ids = 366;
pub const ruby_method_ids_idIFUNC: ruby_method_ids = 367;
pub const ruby_method_ids_idCFUNC: ruby_method_ids = 368;
pub const ruby_method_ids_id_core_set_method_alias: ruby_method_ids = 369;
pub const ruby_method_ids_id_core_set_variable_alias: ruby_method_ids = 370;
pub const ruby_method_ids_id_core_undef_method: ruby_method_ids = 371;
pub const ruby_method_ids_id_core_define_method: ruby_method_ids = 372;
pub const ruby_method_ids_id_core_define_singleton_method: ruby_method_ids = 373;
pub const ruby_method_ids_id_core_set_postexe: ruby_method_ids = 374;
pub const ruby_method_ids_tLAST_TOKEN: ruby_method_ids = 375;
pub const ruby_method_ids_idDot2: ruby_method_ids = 334;
pub const ruby_method_ids_idDot3: ruby_method_ids = 335;
pub const ruby_method_ids_idUPlus: ruby_method_ids = 321;
pub const ruby_method_ids_idUMinus: ruby_method_ids = 322;
pub const ruby_method_ids_idPow: ruby_method_ids = 323;
pub const ruby_method_ids_idCmp: ruby_method_ids = 324;
pub const ruby_method_ids_idPLUS: ruby_method_ids = 43;
pub const ruby_method_ids_idMINUS: ruby_method_ids = 45;
pub const ruby_method_ids_idMULT: ruby_method_ids = 42;
pub const ruby_method_ids_idDIV: ruby_method_ids = 47;
pub const ruby_method_ids_idMOD: ruby_method_ids = 37;
pub const ruby_method_ids_idLT: ruby_method_ids = 60;
pub const ruby_method_ids_idLTLT: ruby_method_ids = 338;
pub const ruby_method_ids_idLE: ruby_method_ids = 329;
pub const ruby_method_ids_idGT: ruby_method_ids = 62;
pub const ruby_method_ids_idGE: ruby_method_ids = 328;
pub const ruby_method_ids_idEq: ruby_method_ids = 325;
pub const ruby_method_ids_idEqq: ruby_method_ids = 326;
pub const ruby_method_ids_idNeq: ruby_method_ids = 327;
pub const ruby_method_ids_idNot: ruby_method_ids = 33;
pub const ruby_method_ids_idBackquote: ruby_method_ids = 96;
pub const ruby_method_ids_idEqTilde: ruby_method_ids = 332;
pub const ruby_method_ids_idNeqTilde: ruby_method_ids = 333;
pub const ruby_method_ids_idAREF: ruby_method_ids = 336;
pub const ruby_method_ids_idASET: ruby_method_ids = 337;
pub const ruby_method_ids_idLAST_TOKEN: ruby_method_ids = 46;
pub const ruby_method_ids_tIntern: ruby_method_ids = 47;
pub const ruby_method_ids_tMethodMissing: ruby_method_ids = 48;
pub const ruby_method_ids_tLength: ruby_method_ids = 49;
pub const ruby_method_ids_tSize: ruby_method_ids = 50;
pub const ruby_method_ids_tGets: ruby_method_ids = 51;
pub const ruby_method_ids_tSucc: ruby_method_ids = 52;
pub const ruby_method_ids_tEach: ruby_method_ids = 53;
pub const ruby_method_ids_tProc: ruby_method_ids = 54;
pub const ruby_method_ids_tLambda: ruby_method_ids = 55;
pub const ruby_method_ids_tSend: ruby_method_ids = 56;
pub const ruby_method_ids_t__send__: ruby_method_ids = 57;
pub const ruby_method_ids_tInitialize: ruby_method_ids = 58;
pub const ruby_method_ids_tUScore: ruby_method_ids = 59;
pub const ruby_method_ids_tLAST_ID: ruby_method_ids = 60;
pub const ruby_method_ids_idIntern: ruby_method_ids = 376;
pub const ruby_method_ids_idMethodMissing: ruby_method_ids = 384;
pub const ruby_method_ids_idLength: ruby_method_ids = 392;
pub const ruby_method_ids_idSize: ruby_method_ids = 400;
pub const ruby_method_ids_idGets: ruby_method_ids = 408;
pub const ruby_method_ids_idSucc: ruby_method_ids = 416;
pub const ruby_method_ids_idEach: ruby_method_ids = 424;
pub const ruby_method_ids_idProc: ruby_method_ids = 432;
pub const ruby_method_ids_idLambda: ruby_method_ids = 440;
pub const ruby_method_ids_idSend: ruby_method_ids = 448;
pub const ruby_method_ids_id__send__: ruby_method_ids = 456;
pub const ruby_method_ids_idInitialize: ruby_method_ids = 464;
pub const ruby_method_ids_idUScore: ruby_method_ids = 472;
pub const ruby_method_ids_idLAST_ID: ruby_method_ids = 480;
pub type ruby_method_ids = ::std::os::raw::c_uint;
pub const rb_method_flag_t_NOEX_PUBLIC: rb_method_flag_t = 0;
pub const rb_method_flag_t_NOEX_NOSUPER: rb_method_flag_t = 1;
pub const rb_method_flag_t_NOEX_PRIVATE: rb_method_flag_t = 2;
pub const rb_method_flag_t_NOEX_PROTECTED: rb_method_flag_t = 4;
pub const rb_method_flag_t_NOEX_MASK: rb_method_flag_t = 6;
pub const rb_method_flag_t_NOEX_BASIC: rb_method_flag_t = 8;
pub const rb_method_flag_t_NOEX_UNDEF: rb_method_flag_t = 1;
pub const rb_method_flag_t_NOEX_MODFUNC: rb_method_flag_t = 18;
pub const rb_method_flag_t_NOEX_SUPER: rb_method_flag_t = 32;
pub const rb_method_flag_t_NOEX_VCALL: rb_method_flag_t = 64;
pub const rb_method_flag_t_NOEX_RESPONDS: rb_method_flag_t = 128;
pub type rb_method_flag_t = ::std::os::raw::c_uint;
pub const rb_method_type_t_VM_METHOD_TYPE_ISEQ: rb_method_type_t = 0;
pub const rb_method_type_t_VM_METHOD_TYPE_CFUNC: rb_method_type_t = 1;
pub const rb_method_type_t_VM_METHOD_TYPE_ATTRSET: rb_method_type_t = 2;
pub const rb_method_type_t_VM_METHOD_TYPE_IVAR: rb_method_type_t = 3;
pub const rb_method_type_t_VM_METHOD_TYPE_BMETHOD: rb_method_type_t = 4;
pub const rb_method_type_t_VM_METHOD_TYPE_ZSUPER: rb_method_type_t = 5;
pub const rb_method_type_t_VM_METHOD_TYPE_UNDEF: rb_method_type_t = 6;
pub const rb_method_type_t_VM_METHOD_TYPE_NOTIMPLEMENTED: rb_method_type_t = 7;
pub const rb_method_type_t_VM_METHOD_TYPE_OPTIMIZED: rb_method_type_t = 8;
pub const rb_method_type_t_VM_METHOD_TYPE_MISSING: rb_method_type_t = 9;
pub type rb_method_type_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_cfunc_struct {
    pub func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
    pub argc: ::std::os::raw::c_int,
}
pub type rb_method_cfunc_t = rb_method_cfunc_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_attr_struct {
    pub id: ID,
    pub location: VALUE,
}
pub type rb_method_attr_t = rb_method_attr_struct;
pub type rb_iseq_t = rb_iseq_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_method_definition_struct {
    pub type_: rb_method_type_t,
    pub original_id: ID,
    pub body: rb_method_definition_struct__bindgen_ty_1,
    pub alias_count: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rb_method_definition_struct__bindgen_ty_1 {
    pub iseq: *mut rb_iseq_t,
    pub cfunc: rb_method_cfunc_t,
    pub attr: rb_method_attr_t,
    pub proc_: VALUE,
    pub optimize_type: rb_method_definition_struct__bindgen_ty_1_method_optimized_type,
}
pub const rb_method_definition_struct__bindgen_ty_1_method_optimized_type_OPTIMIZED_METHOD_TYPE_SEND : rb_method_definition_struct__bindgen_ty_1_method_optimized_type = 0 ;
pub const rb_method_definition_struct__bindgen_ty_1_method_optimized_type_OPTIMIZED_METHOD_TYPE_CALL : rb_method_definition_struct__bindgen_ty_1_method_optimized_type = 1 ;
pub type rb_method_definition_struct__bindgen_ty_1_method_optimized_type = ::std::os::raw::c_uint;
impl ::std::fmt::Debug for rb_method_definition_struct__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "rb_method_definition_struct__bindgen_ty_1 {{ union }}")
    }
}
pub type rb_method_definition_t = rb_method_definition_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_entry_struct {
    pub flag: rb_method_flag_t,
    pub mark: ::std::os::raw::c_char,
    pub def: *mut rb_method_definition_t,
    pub called_id: ID,
    pub klass: VALUE,
}
pub type rb_method_entry_t = rb_method_entry_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unlinked_method_entry_list_entry {
    pub next: *mut unlinked_method_entry_list_entry,
    pub me: *mut rb_method_entry_t,
}
pub type rb_atomic_t = ::std::os::raw::c_uint;
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
pub type rb_thread_id_t = pthread_t;
pub type rb_thread_lock_t = pthread_mutex_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_thread_cond_struct {
    pub cond: pthread_cond_t,
    pub clockid: clockid_t,
}
impl ::std::fmt::Debug for rb_thread_cond_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "rb_thread_cond_struct {{ cond: {:?}, clockid: {:?} }}",
            self.cond, self.clockid
        )
    }
}
pub type rb_thread_cond_t = rb_thread_cond_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct native_thread_data_struct {
    pub signal_thread_list: *mut ::std::os::raw::c_void,
    pub sleep_cond: rb_thread_cond_t,
}
impl ::std::fmt::Debug for native_thread_data_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "native_thread_data_struct {{ signal_thread_list: {:?}, sleep_cond: {:?} }}",
            self.signal_thread_list, self.sleep_cond
        )
    }
}
pub type native_thread_data_t = native_thread_data_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_global_vm_lock_struct {
    pub acquired: ::std::os::raw::c_ulong,
    pub lock: pthread_mutex_t,
    pub waiting: ::std::os::raw::c_ulong,
    pub cond: rb_thread_cond_t,
    pub switch_cond: rb_thread_cond_t,
    pub switch_wait_cond: rb_thread_cond_t,
    pub need_yield: ::std::os::raw::c_int,
    pub wait_yield: ::std::os::raw::c_int,
}
impl ::std::fmt::Debug for rb_global_vm_lock_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rb_global_vm_lock_struct {{ acquired: {:?}, lock: {:?}, waiting: {:?}, cond: {:?}, switch_cond: {:?}, switch_wait_cond: {:?}, need_yield: {:?}, wait_yield: {:?} }}" , self . acquired , self . lock , self . waiting , self . cond , self . switch_cond , self . switch_wait_cond , self . need_yield , self . wait_yield)
    }
}
pub type rb_global_vm_lock_t = rb_global_vm_lock_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type rb_num_t = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_compile_data_ensure_node_stack {
    _unused: [u8; 0],
}
pub type rb_compile_option_t = rb_compile_option_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct iseq_inline_cache_entry {
    pub ic_vmstat: VALUE,
    pub ic_class: VALUE,
    pub ic_value: iseq_inline_cache_entry__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iseq_inline_cache_entry__bindgen_ty_1 {
    pub value: VALUE,
    pub method: *mut rb_method_entry_t,
    pub index: ::std::os::raw::c_long,
}
impl ::std::fmt::Debug for iseq_inline_cache_entry__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "iseq_inline_cache_entry__bindgen_ty_1 {{ union }}")
    }
}
impl ::std::fmt::Debug for iseq_inline_cache_entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "iseq_inline_cache_entry {{ ic_vmstat: {:?}, ic_class: {:?}, ic_value: {:?} }}",
            self.ic_vmstat, self.ic_class, self.ic_value
        )
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_struct {
    pub type_: rb_iseq_struct_iseq_type,
    pub name: VALUE,
    pub filename: VALUE,
    pub filepath: VALUE,
    pub iseq: *mut VALUE,
    pub iseq_encoded: *mut VALUE,
    pub iseq_size: ::std::os::raw::c_ulong,
    pub mark_ary: VALUE,
    pub coverage: VALUE,
    pub line_no: ::std::os::raw::c_ushort,
    pub insn_info_table: *mut iseq_insn_info_entry,
    pub insn_info_size: usize,
    pub local_table: *mut ID,
    pub local_table_size: ::std::os::raw::c_int,
    pub local_size: ::std::os::raw::c_int,
    pub ic_entries: *mut iseq_inline_cache_entry,
    pub ic_size: ::std::os::raw::c_int,
    pub argc: ::std::os::raw::c_int,
    pub arg_simple: ::std::os::raw::c_int,
    pub arg_rest: ::std::os::raw::c_int,
    pub arg_block: ::std::os::raw::c_int,
    pub arg_opts: ::std::os::raw::c_int,
    pub arg_post_len: ::std::os::raw::c_int,
    pub arg_post_start: ::std::os::raw::c_int,
    pub arg_size: ::std::os::raw::c_int,
    pub arg_opt_table: *mut VALUE,
    pub stack_max: usize,
    pub catch_table: *mut iseq_catch_table_entry,
    pub catch_table_size: ::std::os::raw::c_int,
    pub parent_iseq: *mut rb_iseq_struct,
    pub local_iseq: *mut rb_iseq_struct,
    pub self_: VALUE,
    pub orig: VALUE,
    pub cref_stack: *mut NODE,
    pub klass: VALUE,
    pub defined_method_id: ID,
    pub flip_cnt: rb_num_t,
    pub compile_data: *mut iseq_compile_data,
}
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_TOP: rb_iseq_struct_iseq_type = 0;
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_METHOD: rb_iseq_struct_iseq_type = 1;
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_BLOCK: rb_iseq_struct_iseq_type = 2;
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_CLASS: rb_iseq_struct_iseq_type = 3;
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_RESCUE: rb_iseq_struct_iseq_type = 4;
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_ENSURE: rb_iseq_struct_iseq_type = 5;
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_EVAL: rb_iseq_struct_iseq_type = 6;
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_MAIN: rb_iseq_struct_iseq_type = 7;
pub const rb_iseq_struct_iseq_type_ISEQ_TYPE_DEFINED_GUARD: rb_iseq_struct_iseq_type = 8;
pub type rb_iseq_struct_iseq_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_objspace {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_vm_struct {
    pub self_: VALUE,
    pub gvl: rb_global_vm_lock_t,
    pub main_thread: *mut rb_thread_struct,
    pub running_thread: *mut rb_thread_struct,
    pub living_threads: *mut st_table,
    pub thgroup_default: VALUE,
    pub running: ::std::os::raw::c_int,
    pub inhibit_thread_creation: ::std::os::raw::c_int,
    pub thread_abort_on_exception: ::std::os::raw::c_int,
    pub trace_flag: ::std::os::raw::c_ulong,
    pub sleeper: ::std::os::raw::c_int,
    pub mark_object_ary: VALUE,
    pub special_exceptions: [VALUE; 4usize],
    pub top_self: VALUE,
    pub load_path: VALUE,
    pub loaded_features: VALUE,
    pub loading_table: *mut st_table,
    pub trap_list: [rb_vm_struct__bindgen_ty_1; 65usize],
    pub event_hooks: *mut rb_event_hook_t,
    pub src_encoding_index: ::std::os::raw::c_int,
    pub verbose: VALUE,
    pub debug: VALUE,
    pub progname: VALUE,
    pub coverages: VALUE,
    pub unlinked_method_entry_list: *mut unlinked_method_entry_list_entry,
    pub objspace: *mut rb_objspace,
    pub at_exit: RArray,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_vm_struct__bindgen_ty_1 {
    pub cmd: VALUE,
    pub safe: ::std::os::raw::c_int,
}
impl ::std::fmt::Debug for rb_vm_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rb_vm_struct {{ self: {:?}, gvl: {:?}, main_thread: {:?}, running_thread: {:?}, living_threads: {:?}, thgroup_default: {:?}, running: {:?}, inhibit_thread_creation: {:?}, thread_abort_on_exception: {:?}, trace_flag: {:?}, sleeper: {:?}, mark_object_ary: {:?}, special_exceptions: {:?}, top_self: {:?}, load_path: {:?}, loaded_features: {:?}, loading_table: {:?}, trap_list: {:?}, event_hooks: {:?}, src_encoding_index: {:?}, verbose: {:?}, debug: {:?}, progname: {:?}, coverages: {:?}, unlinked_method_entry_list: {:?}, objspace: {:?}, at_exit: {:?} }}" , self . self_ , self . gvl , self . main_thread , self . running_thread , self . living_threads , self . thgroup_default , self . running , self . inhibit_thread_creation , self . thread_abort_on_exception , self . trace_flag , self . sleeper , self . mark_object_ary , self . special_exceptions , self . top_self , self . load_path , self . loaded_features , self . loading_table , self . trap_list , self . event_hooks , self . src_encoding_index , self . verbose , self . debug , self . progname , self . coverages , self . unlinked_method_entry_list , self . objspace , self . at_exit)
    }
}
pub type rb_vm_t = rb_vm_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_control_frame_t {
    pub pc: *mut VALUE,
    pub sp: *mut VALUE,
    pub bp: *mut VALUE,
    pub iseq: *mut rb_iseq_t,
    pub flag: VALUE,
    pub self_: VALUE,
    pub lfp: *mut VALUE,
    pub dfp: *mut VALUE,
    pub block_iseq: *mut rb_iseq_t,
    pub proc_: VALUE,
    pub me: *const rb_method_entry_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_block_struct {
    pub self_: VALUE,
    pub lfp: *mut VALUE,
    pub dfp: *mut VALUE,
    pub iseq: *mut rb_iseq_t,
    pub proc_: VALUE,
}
pub type rb_block_t = rb_block_struct;
pub const rb_thread_status_THREAD_TO_KILL: rb_thread_status = 0;
pub const rb_thread_status_THREAD_RUNNABLE: rb_thread_status = 1;
pub const rb_thread_status_THREAD_STOPPED: rb_thread_status = 2;
pub const rb_thread_status_THREAD_STOPPED_FOREVER: rb_thread_status = 3;
pub const rb_thread_status_THREAD_KILLED: rb_thread_status = 4;
pub type rb_thread_status = ::std::os::raw::c_uint;
pub type rb_jmpbuf_t = jmp_buf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_vm_tag {
    pub buf: rb_jmpbuf_t,
    pub tag: VALUE,
    pub retval: VALUE,
    pub prev: *mut rb_vm_tag,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_vm_protect_tag {
    pub prev: *mut rb_vm_protect_tag,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_unblock_callback {
    pub func: rb_unblock_function_t,
    pub arg: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_mutex_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_thread_struct {
    pub self_: VALUE,
    pub vm: *mut rb_vm_t,
    pub stack: *mut VALUE,
    pub stack_size: ::std::os::raw::c_ulong,
    pub cfp: *mut rb_control_frame_t,
    pub safe_level: ::std::os::raw::c_int,
    pub raised_flag: ::std::os::raw::c_int,
    pub last_status: VALUE,
    pub state: ::std::os::raw::c_int,
    pub waiting_fd: ::std::os::raw::c_int,
    pub passed_block: *const rb_block_t,
    pub passed_me: *const rb_method_entry_t,
    pub top_self: VALUE,
    pub top_wrapper: VALUE,
    pub base_block: *mut rb_block_t,
    pub local_lfp: *mut VALUE,
    pub local_svar: VALUE,
    pub thread_id: rb_thread_id_t,
    pub status: rb_thread_status,
    pub priority: ::std::os::raw::c_int,
    pub native_thread_data: native_thread_data_t,
    pub blocking_region_buffer: *mut ::std::os::raw::c_void,
    pub thgroup: VALUE,
    pub value: VALUE,
    pub errinfo: VALUE,
    pub thrown_errinfo: VALUE,
    pub interrupt_flag: rb_atomic_t,
    pub interrupt_lock: rb_thread_lock_t,
    pub unblock: rb_unblock_callback,
    pub locking_mutex: VALUE,
    pub keeping_mutexes: *mut rb_mutex_struct,
    pub tag: *mut rb_vm_tag,
    pub protect_tag: *mut rb_vm_protect_tag,
    pub parse_in_eval: ::std::os::raw::c_int,
    pub mild_compile_error: ::std::os::raw::c_int,
    pub local_storage: *mut st_table,
    pub join_list_next: *mut rb_thread_struct,
    pub join_list_head: *mut rb_thread_struct,
    pub first_proc: VALUE,
    pub first_args: VALUE,
    pub first_func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
    pub machine_stack_start: *mut VALUE,
    pub machine_stack_end: *mut VALUE,
    pub machine_stack_maxsize: usize,
    pub machine_regs: jmp_buf,
    pub mark_stack_len: ::std::os::raw::c_int,
    pub stat_insn_usage: VALUE,
    pub event_hooks: *mut rb_event_hook_t,
    pub event_flags: rb_event_flag_t,
    pub tracing: ::std::os::raw::c_int,
    pub fiber: VALUE,
    pub root_fiber: VALUE,
    pub root_jmpbuf: rb_jmpbuf_t,
    pub method_missing_reason: ::std::os::raw::c_int,
    pub abort_on_exception: ::std::os::raw::c_int,
    pub altstack: *mut ::std::os::raw::c_void,
    pub running_time_us: ::std::os::raw::c_ulong,
}
impl ::std::fmt::Debug for rb_thread_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rb_thread_struct {{ self: {:?}, vm: {:?}, stack: {:?}, stack_size: {:?}, cfp: {:?}, safe_level: {:?}, raised_flag: {:?}, last_status: {:?}, state: {:?}, waiting_fd: {:?}, passed_block: {:?}, passed_me: {:?}, top_self: {:?}, top_wrapper: {:?}, base_block: {:?}, local_lfp: {:?}, local_svar: {:?}, thread_id: {:?}, status: {:?}, priority: {:?}, native_thread_data: {:?}, blocking_region_buffer: {:?}, thgroup: {:?}, value: {:?}, errinfo: {:?}, thrown_errinfo: {:?}, interrupt_flag: {:?}, interrupt_lock: {:?}, unblock: {:?}, locking_mutex: {:?}, keeping_mutexes: {:?}, tag: {:?}, protect_tag: {:?}, parse_in_eval: {:?}, mild_compile_error: {:?}, local_storage: {:?}, join_list_next: {:?}, join_list_head: {:?}, first_proc: {:?}, first_args: {:?}, first_func: {:?}, machine_stack_start: {:?}, machine_stack_end: {:?}, machine_regs: {:?}, mark_stack_len: {:?}, stat_insn_usage: {:?}, event_hooks: {:?}, event_flags: {:?}, tracing: {:?}, fiber: {:?}, root_fiber: {:?}, root_jmpbuf: {:?}, method_missing_reason: {:?}, abort_on_exception: {:?}, altstack: {:?}, running_time_us: {:?} }}" , self . self_ , self . vm , self . stack , self . stack_size , self . cfp , self . safe_level , self . raised_flag , self . last_status , self . state , self . waiting_fd , self . passed_block , self . passed_me , self . top_self , self . top_wrapper , self . base_block , self . local_lfp , self . local_svar , self . thread_id , self . status , self . priority , self . native_thread_data , self . blocking_region_buffer , self . thgroup , self . value , self . errinfo , self . thrown_errinfo , self . interrupt_flag , self . interrupt_lock , self . unblock , self . locking_mutex , self . keeping_mutexes , self . tag , self . protect_tag , self . parse_in_eval , self . mild_compile_error , self . local_storage , self . join_list_next , self . join_list_head , self . first_proc , self . first_args , self . first_func , self . machine_stack_start , self . machine_stack_end , self . machine_regs , self . mark_stack_len , self . stat_insn_usage , self . event_hooks , self . event_flags , self . tracing , self . fiber , self . root_fiber , self . root_jmpbuf , self . method_missing_reason , self . abort_on_exception , self . altstack , self . running_time_us)
    }
}
pub type rb_thread_t = rb_thread_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_compile_option_struct {
    pub inline_const_cache: ::std::os::raw::c_int,
    pub peephole_optimization: ::std::os::raw::c_int,
    pub tailcall_optimization: ::std::os::raw::c_int,
    pub specialized_instruction: ::std::os::raw::c_int,
    pub operands_unification: ::std::os::raw::c_int,
    pub instructions_unification: ::std::os::raw::c_int,
    pub stack_caching: ::std::os::raw::c_int,
    pub trace_instruction: ::std::os::raw::c_int,
    pub debug_level: ::std::os::raw::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_insn_info_entry {
    pub position: ::std::os::raw::c_ushort,
    pub line_no: ::std::os::raw::c_ushort,
    pub sp: ::std::os::raw::c_ushort,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_catch_table_entry {
    pub type_: iseq_catch_table_entry_catch_type,
    pub iseq: VALUE,
    pub start: ::std::os::raw::c_ulong,
    pub end: ::std::os::raw::c_ulong,
    pub cont: ::std::os::raw::c_ulong,
    pub sp: ::std::os::raw::c_ulong,
}
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_RESCUE: iseq_catch_table_entry_catch_type =
    0;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_ENSURE: iseq_catch_table_entry_catch_type =
    1;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_RETRY: iseq_catch_table_entry_catch_type = 2;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_BREAK: iseq_catch_table_entry_catch_type = 3;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_REDO: iseq_catch_table_entry_catch_type = 4;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_NEXT: iseq_catch_table_entry_catch_type = 5;
pub type iseq_catch_table_entry_catch_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_compile_data_storage {
    pub next: *mut iseq_compile_data_storage,
    pub pos: ::std::os::raw::c_ulong,
    pub size: ::std::os::raw::c_ulong,
    pub buff: *mut ::std::os::raw::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_compile_data {
    pub err_info: VALUE,
    pub mark_ary: VALUE,
    pub catch_table_ary: VALUE,
    pub start_label: *mut iseq_label_data,
    pub end_label: *mut iseq_label_data,
    pub redo_label: *mut iseq_label_data,
    pub current_block: VALUE,
    pub ensure_node: VALUE,
    pub for_iseq: VALUE,
    pub ensure_node_stack: *mut iseq_compile_data_ensure_node_stack,
    pub loopval_popped: ::std::os::raw::c_int,
    pub cached_const: ::std::os::raw::c_int,
    pub storage_head: *mut iseq_compile_data_storage,
    pub storage_current: *mut iseq_compile_data_storage,
    pub last_line: ::std::os::raw::c_int,
    pub last_coverable_line: ::std::os::raw::c_int,
    pub label_no: ::std::os::raw::c_int,
    pub node_level: ::std::os::raw::c_int,
    pub option: *const rb_compile_option_t,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table_entry {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_label_data {
    pub _address: u8,
}
