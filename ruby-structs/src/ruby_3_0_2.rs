/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type size_t = usize;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [usize; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    fn test_field___val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__sigset_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__sigset_t),
                "::",
                stringify!(__val)
            )
        );
    }
    test_field___val();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    fn test_field___prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
    }
    test_field___prev();
    fn test_field___next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_internal_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    test_field___next();
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    fn test_field___lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
    }
    test_field___lock();
    fn test_field___count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
    }
    test_field___count();
    fn test_field___owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
    }
    test_field___owner();
    fn test_field___nusers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
    }
    test_field___nusers();
    fn test_field___kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
    }
    test_field___kind();
    fn test_field___spins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
    }
    test_field___spins();
    fn test_field___elision() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
    }
    test_field___elision();
    fn test_field___list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_mutex_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    test_field___list();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    fn test_field___wseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1),
                "::",
                stringify!(__wseq)
            )
        );
    }
    test_field___wseq();
    fn test_field___wseq32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_1),
                "::",
                stringify!(__wseq32)
            )
        );
    }
    test_field___wseq32();
}
impl ::std::fmt::Debug for __pthread_cond_s__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__pthread_cond_s__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    fn test_field___low() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(__low)
            )
        );
    }
    test_field___low();
    fn test_field___high() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
                "::",
                stringify!(__high)
            )
        );
    }
    test_field___high();
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    fn test_field___g1_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2),
                "::",
                stringify!(__g1_start)
            )
        );
    }
    test_field___g1_start();
    fn test_field___g1_start32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s__bindgen_ty_2),
                "::",
                stringify!(__g1_start32)
            )
        );
    }
    test_field___g1_start32();
}
impl ::std::fmt::Debug for __pthread_cond_s__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "__pthread_cond_s__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    fn test_field___g_refs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_refs)
            )
        );
    }
    test_field___g_refs();
    fn test_field___g_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_size)
            )
        );
    }
    test_field___g_size();
    fn test_field___g1_orig_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g1_orig_size)
            )
        );
    }
    test_field___g1_orig_size();
    fn test_field___wrefs() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__wrefs)
            )
        );
    }
    test_field___wrefs();
    fn test_field___g_signals() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__pthread_cond_s>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_cond_s),
                "::",
                stringify!(__g_signals)
            )
        );
    }
    test_field___g_signals();
}
impl ::std::fmt::Debug for __pthread_cond_s {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "__pthread_cond_s {{ __bindgen_anon_1: {:?}, __bindgen_anon_2: {:?}, __g_refs: {:?}, __g_size: {:?}, __g1_orig_size: {:?}, __wrefs: {:?}, __g_signals: {:?} }}" , self . __bindgen_anon_1 , self . __bindgen_anon_2 , self . __g_refs , self . __g_size , self . __g1_orig_size , self . __wrefs , self . __g_signals)
    }
}
pub type pthread_t = usize;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_mutex_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
impl ::std::fmt::Debug for pthread_mutex_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_mutex_t {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    fn test_field___data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__data)
            )
        );
    }
    test_field___data();
    fn test_field___size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__size)
            )
        );
    }
    test_field___size();
    fn test_field___align() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<pthread_cond_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_cond_t),
                "::",
                stringify!(__align)
            )
        );
    }
    test_field___align();
}
impl ::std::fmt::Debug for pthread_cond_t {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "pthread_cond_t {{ union }}")
    }
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag() {
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    fn test_field___jmpbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__jmpbuf)
            )
        );
    }
    test_field___jmpbuf();
    fn test_field___mask_was_saved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__mask_was_saved)
            )
        );
    }
    test_field___mask_was_saved();
    fn test_field___saved_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<__jmp_buf_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(__jmp_buf_tag),
                "::",
                stringify!(__saved_mask)
            )
        );
    }
    test_field___saved_mask();
}
pub type jmp_buf = [__jmp_buf_tag; 1usize];
pub type sigjmp_buf = [__jmp_buf_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_node {
    pub next: *mut list_node,
    pub prev: *mut list_node,
}
#[test]
fn bindgen_test_layout_list_node() {
    assert_eq!(
        ::std::mem::size_of::<list_node>(),
        16usize,
        concat!("Size of: ", stringify!(list_node))
    );
    assert_eq!(
        ::std::mem::align_of::<list_node>(),
        8usize,
        concat!("Alignment of ", stringify!(list_node))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<list_node>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(list_node),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<list_node>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(list_node),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct list_head {
    pub n: list_node,
}
#[test]
fn bindgen_test_layout_list_head() {
    assert_eq!(
        ::std::mem::size_of::<list_head>(),
        16usize,
        concat!("Size of: ", stringify!(list_head))
    );
    assert_eq!(
        ::std::mem::align_of::<list_head>(),
        8usize,
        concat!("Alignment of ", stringify!(list_head))
    );
    fn test_field_n() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<list_head>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(list_head),
                "::",
                stringify!(n)
            )
        );
    }
    test_field_n();
}
pub const ruby_id_types_RUBY_ID_STATIC_SYM: ruby_id_types = 1;
pub const ruby_id_types_RUBY_ID_LOCAL: ruby_id_types = 0;
pub const ruby_id_types_RUBY_ID_INSTANCE: ruby_id_types = 2;
pub const ruby_id_types_RUBY_ID_GLOBAL: ruby_id_types = 6;
pub const ruby_id_types_RUBY_ID_ATTRSET: ruby_id_types = 8;
pub const ruby_id_types_RUBY_ID_CONST: ruby_id_types = 10;
pub const ruby_id_types_RUBY_ID_CLASS: ruby_id_types = 12;
pub const ruby_id_types_RUBY_ID_JUNK: ruby_id_types = 14;
pub const ruby_id_types_RUBY_ID_INTERNAL: ruby_id_types = 14;
pub const ruby_id_types_RUBY_ID_SCOPE_SHIFT: ruby_id_types = 4;
pub const ruby_id_types_RUBY_ID_SCOPE_MASK: ruby_id_types = 14;
pub type ruby_id_types = ::std::os::raw::c_uint;
pub const ruby_method_ids_idDot2: ruby_method_ids = 128;
pub const ruby_method_ids_idDot3: ruby_method_ids = 129;
pub const ruby_method_ids_idUPlus: ruby_method_ids = 132;
pub const ruby_method_ids_idUMinus: ruby_method_ids = 133;
pub const ruby_method_ids_idPow: ruby_method_ids = 134;
pub const ruby_method_ids_idCmp: ruby_method_ids = 135;
pub const ruby_method_ids_idPLUS: ruby_method_ids = 43;
pub const ruby_method_ids_idMINUS: ruby_method_ids = 45;
pub const ruby_method_ids_idMULT: ruby_method_ids = 42;
pub const ruby_method_ids_idDIV: ruby_method_ids = 47;
pub const ruby_method_ids_idMOD: ruby_method_ids = 37;
pub const ruby_method_ids_idLTLT: ruby_method_ids = 136;
pub const ruby_method_ids_idGTGT: ruby_method_ids = 137;
pub const ruby_method_ids_idLT: ruby_method_ids = 60;
pub const ruby_method_ids_idLE: ruby_method_ids = 138;
pub const ruby_method_ids_idGT: ruby_method_ids = 62;
pub const ruby_method_ids_idGE: ruby_method_ids = 139;
pub const ruby_method_ids_idEq: ruby_method_ids = 140;
pub const ruby_method_ids_idEqq: ruby_method_ids = 141;
pub const ruby_method_ids_idNeq: ruby_method_ids = 142;
pub const ruby_method_ids_idNot: ruby_method_ids = 33;
pub const ruby_method_ids_idAnd: ruby_method_ids = 38;
pub const ruby_method_ids_idOr: ruby_method_ids = 124;
pub const ruby_method_ids_idBackquote: ruby_method_ids = 96;
pub const ruby_method_ids_idEqTilde: ruby_method_ids = 143;
pub const ruby_method_ids_idNeqTilde: ruby_method_ids = 144;
pub const ruby_method_ids_idAREF: ruby_method_ids = 145;
pub const ruby_method_ids_idASET: ruby_method_ids = 146;
pub const ruby_method_ids_idCOLON2: ruby_method_ids = 147;
pub const ruby_method_ids_idANDOP: ruby_method_ids = 148;
pub const ruby_method_ids_idOROP: ruby_method_ids = 149;
pub const ruby_method_ids_idANDDOT: ruby_method_ids = 150;
pub const ruby_method_ids_tPRESERVED_ID_BEGIN: ruby_method_ids = 150;
pub const ruby_method_ids_idNilP: ruby_method_ids = 151;
pub const ruby_method_ids_idNULL: ruby_method_ids = 152;
pub const ruby_method_ids_idEmptyP: ruby_method_ids = 153;
pub const ruby_method_ids_idEqlP: ruby_method_ids = 154;
pub const ruby_method_ids_idRespond_to: ruby_method_ids = 155;
pub const ruby_method_ids_idRespond_to_missing: ruby_method_ids = 156;
pub const ruby_method_ids_idIFUNC: ruby_method_ids = 157;
pub const ruby_method_ids_idCFUNC: ruby_method_ids = 158;
pub const ruby_method_ids_id_core_set_method_alias: ruby_method_ids = 159;
pub const ruby_method_ids_id_core_set_variable_alias: ruby_method_ids = 160;
pub const ruby_method_ids_id_core_undef_method: ruby_method_ids = 161;
pub const ruby_method_ids_id_core_define_method: ruby_method_ids = 162;
pub const ruby_method_ids_id_core_define_singleton_method: ruby_method_ids = 163;
pub const ruby_method_ids_id_core_set_postexe: ruby_method_ids = 164;
pub const ruby_method_ids_id_core_hash_merge_ptr: ruby_method_ids = 165;
pub const ruby_method_ids_id_core_hash_merge_kwd: ruby_method_ids = 166;
pub const ruby_method_ids_id_core_raise: ruby_method_ids = 167;
pub const ruby_method_ids_id_debug_created_info: ruby_method_ids = 168;
pub const ruby_method_ids_tPRESERVED_ID_END: ruby_method_ids = 169;
pub const ruby_method_ids_tTOKEN_LOCAL_BEGIN: ruby_method_ids = 168;
pub const ruby_method_ids_tMax: ruby_method_ids = 169;
pub const ruby_method_ids_tMin: ruby_method_ids = 170;
pub const ruby_method_ids_tFreeze: ruby_method_ids = 171;
pub const ruby_method_ids_tInspect: ruby_method_ids = 172;
pub const ruby_method_ids_tIntern: ruby_method_ids = 173;
pub const ruby_method_ids_tObject_id: ruby_method_ids = 174;
pub const ruby_method_ids_tConst_missing: ruby_method_ids = 175;
pub const ruby_method_ids_tMethodMissing: ruby_method_ids = 176;
pub const ruby_method_ids_tMethod_added: ruby_method_ids = 177;
pub const ruby_method_ids_tSingleton_method_added: ruby_method_ids = 178;
pub const ruby_method_ids_tMethod_removed: ruby_method_ids = 179;
pub const ruby_method_ids_tSingleton_method_removed: ruby_method_ids = 180;
pub const ruby_method_ids_tMethod_undefined: ruby_method_ids = 181;
pub const ruby_method_ids_tSingleton_method_undefined: ruby_method_ids = 182;
pub const ruby_method_ids_tLength: ruby_method_ids = 183;
pub const ruby_method_ids_tSize: ruby_method_ids = 184;
pub const ruby_method_ids_tGets: ruby_method_ids = 185;
pub const ruby_method_ids_tSucc: ruby_method_ids = 186;
pub const ruby_method_ids_tEach: ruby_method_ids = 187;
pub const ruby_method_ids_tProc: ruby_method_ids = 188;
pub const ruby_method_ids_tLambda: ruby_method_ids = 189;
pub const ruby_method_ids_tSend: ruby_method_ids = 190;
pub const ruby_method_ids_t__send__: ruby_method_ids = 191;
pub const ruby_method_ids_t__attached__: ruby_method_ids = 192;
pub const ruby_method_ids_tInitialize: ruby_method_ids = 193;
pub const ruby_method_ids_tInitialize_copy: ruby_method_ids = 194;
pub const ruby_method_ids_tInitialize_clone: ruby_method_ids = 195;
pub const ruby_method_ids_tInitialize_dup: ruby_method_ids = 196;
pub const ruby_method_ids_tTo_int: ruby_method_ids = 197;
pub const ruby_method_ids_tTo_ary: ruby_method_ids = 198;
pub const ruby_method_ids_tTo_str: ruby_method_ids = 199;
pub const ruby_method_ids_tTo_sym: ruby_method_ids = 200;
pub const ruby_method_ids_tTo_hash: ruby_method_ids = 201;
pub const ruby_method_ids_tTo_proc: ruby_method_ids = 202;
pub const ruby_method_ids_tTo_io: ruby_method_ids = 203;
pub const ruby_method_ids_tTo_a: ruby_method_ids = 204;
pub const ruby_method_ids_tTo_s: ruby_method_ids = 205;
pub const ruby_method_ids_tTo_i: ruby_method_ids = 206;
pub const ruby_method_ids_tTo_f: ruby_method_ids = 207;
pub const ruby_method_ids_tTo_r: ruby_method_ids = 208;
pub const ruby_method_ids_tBt: ruby_method_ids = 209;
pub const ruby_method_ids_tBt_locations: ruby_method_ids = 210;
pub const ruby_method_ids_tCall: ruby_method_ids = 211;
pub const ruby_method_ids_tMesg: ruby_method_ids = 212;
pub const ruby_method_ids_tException: ruby_method_ids = 213;
pub const ruby_method_ids_tLocals: ruby_method_ids = 214;
pub const ruby_method_ids_tNOT: ruby_method_ids = 215;
pub const ruby_method_ids_tAND: ruby_method_ids = 216;
pub const ruby_method_ids_tOR: ruby_method_ids = 217;
pub const ruby_method_ids_tDiv: ruby_method_ids = 218;
pub const ruby_method_ids_tDivmod: ruby_method_ids = 219;
pub const ruby_method_ids_tFdiv: ruby_method_ids = 220;
pub const ruby_method_ids_tQuo: ruby_method_ids = 221;
pub const ruby_method_ids_tName: ruby_method_ids = 222;
pub const ruby_method_ids_tNil: ruby_method_ids = 223;
pub const ruby_method_ids_tUScore: ruby_method_ids = 224;
pub const ruby_method_ids_tNUMPARAM_1: ruby_method_ids = 225;
pub const ruby_method_ids_tNUMPARAM_2: ruby_method_ids = 226;
pub const ruby_method_ids_tNUMPARAM_3: ruby_method_ids = 227;
pub const ruby_method_ids_tNUMPARAM_4: ruby_method_ids = 228;
pub const ruby_method_ids_tNUMPARAM_5: ruby_method_ids = 229;
pub const ruby_method_ids_tNUMPARAM_6: ruby_method_ids = 230;
pub const ruby_method_ids_tNUMPARAM_7: ruby_method_ids = 231;
pub const ruby_method_ids_tNUMPARAM_8: ruby_method_ids = 232;
pub const ruby_method_ids_tNUMPARAM_9: ruby_method_ids = 233;
pub const ruby_method_ids_tTOKEN_LOCAL_END: ruby_method_ids = 234;
pub const ruby_method_ids_tTOKEN_INSTANCE_BEGIN: ruby_method_ids = 233;
pub const ruby_method_ids_tTOKEN_INSTANCE_END: ruby_method_ids = 234;
pub const ruby_method_ids_tTOKEN_GLOBAL_BEGIN: ruby_method_ids = 233;
pub const ruby_method_ids_tLASTLINE: ruby_method_ids = 234;
pub const ruby_method_ids_tBACKREF: ruby_method_ids = 235;
pub const ruby_method_ids_tERROR_INFO: ruby_method_ids = 236;
pub const ruby_method_ids_tTOKEN_GLOBAL_END: ruby_method_ids = 237;
pub const ruby_method_ids_tTOKEN_CONST_BEGIN: ruby_method_ids = 236;
pub const ruby_method_ids_tTOKEN_CONST_END: ruby_method_ids = 237;
pub const ruby_method_ids_tTOKEN_CLASS_BEGIN: ruby_method_ids = 236;
pub const ruby_method_ids_tTOKEN_CLASS_END: ruby_method_ids = 237;
pub const ruby_method_ids_tTOKEN_ATTRSET_BEGIN: ruby_method_ids = 236;
pub const ruby_method_ids_tTOKEN_ATTRSET_END: ruby_method_ids = 237;
pub const ruby_method_ids_tNEXT_ID: ruby_method_ids = 237;
pub const ruby_method_ids_idMax: ruby_method_ids = 2705;
pub const ruby_method_ids_idMin: ruby_method_ids = 2721;
pub const ruby_method_ids_idFreeze: ruby_method_ids = 2737;
pub const ruby_method_ids_idInspect: ruby_method_ids = 2753;
pub const ruby_method_ids_idIntern: ruby_method_ids = 2769;
pub const ruby_method_ids_idObject_id: ruby_method_ids = 2785;
pub const ruby_method_ids_idConst_missing: ruby_method_ids = 2801;
pub const ruby_method_ids_idMethodMissing: ruby_method_ids = 2817;
pub const ruby_method_ids_idMethod_added: ruby_method_ids = 2833;
pub const ruby_method_ids_idSingleton_method_added: ruby_method_ids = 2849;
pub const ruby_method_ids_idMethod_removed: ruby_method_ids = 2865;
pub const ruby_method_ids_idSingleton_method_removed: ruby_method_ids = 2881;
pub const ruby_method_ids_idMethod_undefined: ruby_method_ids = 2897;
pub const ruby_method_ids_idSingleton_method_undefined: ruby_method_ids = 2913;
pub const ruby_method_ids_idLength: ruby_method_ids = 2929;
pub const ruby_method_ids_idSize: ruby_method_ids = 2945;
pub const ruby_method_ids_idGets: ruby_method_ids = 2961;
pub const ruby_method_ids_idSucc: ruby_method_ids = 2977;
pub const ruby_method_ids_idEach: ruby_method_ids = 2993;
pub const ruby_method_ids_idProc: ruby_method_ids = 3009;
pub const ruby_method_ids_idLambda: ruby_method_ids = 3025;
pub const ruby_method_ids_idSend: ruby_method_ids = 3041;
pub const ruby_method_ids_id__send__: ruby_method_ids = 3057;
pub const ruby_method_ids_id__attached__: ruby_method_ids = 3073;
pub const ruby_method_ids_idInitialize: ruby_method_ids = 3089;
pub const ruby_method_ids_idInitialize_copy: ruby_method_ids = 3105;
pub const ruby_method_ids_idInitialize_clone: ruby_method_ids = 3121;
pub const ruby_method_ids_idInitialize_dup: ruby_method_ids = 3137;
pub const ruby_method_ids_idTo_int: ruby_method_ids = 3153;
pub const ruby_method_ids_idTo_ary: ruby_method_ids = 3169;
pub const ruby_method_ids_idTo_str: ruby_method_ids = 3185;
pub const ruby_method_ids_idTo_sym: ruby_method_ids = 3201;
pub const ruby_method_ids_idTo_hash: ruby_method_ids = 3217;
pub const ruby_method_ids_idTo_proc: ruby_method_ids = 3233;
pub const ruby_method_ids_idTo_io: ruby_method_ids = 3249;
pub const ruby_method_ids_idTo_a: ruby_method_ids = 3265;
pub const ruby_method_ids_idTo_s: ruby_method_ids = 3281;
pub const ruby_method_ids_idTo_i: ruby_method_ids = 3297;
pub const ruby_method_ids_idTo_f: ruby_method_ids = 3313;
pub const ruby_method_ids_idTo_r: ruby_method_ids = 3329;
pub const ruby_method_ids_idBt: ruby_method_ids = 3345;
pub const ruby_method_ids_idBt_locations: ruby_method_ids = 3361;
pub const ruby_method_ids_idCall: ruby_method_ids = 3377;
pub const ruby_method_ids_idMesg: ruby_method_ids = 3393;
pub const ruby_method_ids_idException: ruby_method_ids = 3409;
pub const ruby_method_ids_idLocals: ruby_method_ids = 3425;
pub const ruby_method_ids_idNOT: ruby_method_ids = 3441;
pub const ruby_method_ids_idAND: ruby_method_ids = 3457;
pub const ruby_method_ids_idOR: ruby_method_ids = 3473;
pub const ruby_method_ids_idDiv: ruby_method_ids = 3489;
pub const ruby_method_ids_idDivmod: ruby_method_ids = 3505;
pub const ruby_method_ids_idFdiv: ruby_method_ids = 3521;
pub const ruby_method_ids_idQuo: ruby_method_ids = 3537;
pub const ruby_method_ids_idName: ruby_method_ids = 3553;
pub const ruby_method_ids_idNil: ruby_method_ids = 3569;
pub const ruby_method_ids_idUScore: ruby_method_ids = 3585;
pub const ruby_method_ids_idNUMPARAM_1: ruby_method_ids = 3601;
pub const ruby_method_ids_idNUMPARAM_2: ruby_method_ids = 3617;
pub const ruby_method_ids_idNUMPARAM_3: ruby_method_ids = 3633;
pub const ruby_method_ids_idNUMPARAM_4: ruby_method_ids = 3649;
pub const ruby_method_ids_idNUMPARAM_5: ruby_method_ids = 3665;
pub const ruby_method_ids_idNUMPARAM_6: ruby_method_ids = 3681;
pub const ruby_method_ids_idNUMPARAM_7: ruby_method_ids = 3697;
pub const ruby_method_ids_idNUMPARAM_8: ruby_method_ids = 3713;
pub const ruby_method_ids_idNUMPARAM_9: ruby_method_ids = 3729;
pub const ruby_method_ids_idLASTLINE: ruby_method_ids = 3751;
pub const ruby_method_ids_idBACKREF: ruby_method_ids = 3767;
pub const ruby_method_ids_idERROR_INFO: ruby_method_ids = 3783;
pub const ruby_method_ids_tLAST_OP_ID: ruby_method_ids = 168;
pub const ruby_method_ids_idLAST_OP_ID: ruby_method_ids = 10;
pub type ruby_method_ids = ::std::os::raw::c_uint;
pub type VALUE = usize;
pub type ID = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RBasic {
    pub flags: VALUE,
    pub klass: VALUE,
}
#[test]
fn bindgen_test_layout_RBasic() {
    assert_eq!(
        ::std::mem::size_of::<RBasic>(),
        16usize,
        concat!("Size of: ", stringify!(RBasic))
    );
    assert_eq!(
        ::std::mem::align_of::<RBasic>(),
        8usize,
        concat!("Alignment of ", stringify!(RBasic))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RBasic>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RBasic),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_klass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RBasic>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).klass) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RBasic),
                "::",
                stringify!(klass)
            )
        );
    }
    test_field_klass();
}
pub const ruby_fl_ushift_RUBY_FL_USHIFT: ruby_fl_ushift = 12;
pub type ruby_fl_ushift = ::std::os::raw::c_uint;
pub const ruby_fl_type_RUBY_FL_WB_PROTECTED: ruby_fl_type = 32;
pub const ruby_fl_type_RUBY_FL_PROMOTED0: ruby_fl_type = 32;
pub const ruby_fl_type_RUBY_FL_PROMOTED1: ruby_fl_type = 64;
pub const ruby_fl_type_RUBY_FL_PROMOTED: ruby_fl_type = 96;
pub const ruby_fl_type_RUBY_FL_FINALIZE: ruby_fl_type = 128;
pub const ruby_fl_type_RUBY_FL_TAINT: ruby_fl_type = 256;
pub const ruby_fl_type_RUBY_FL_SHAREABLE: ruby_fl_type = 256;
pub const ruby_fl_type_RUBY_FL_UNTRUSTED: ruby_fl_type = 256;
pub const ruby_fl_type_RUBY_FL_SEEN_OBJ_ID: ruby_fl_type = 512;
pub const ruby_fl_type_RUBY_FL_EXIVAR: ruby_fl_type = 1024;
pub const ruby_fl_type_RUBY_FL_FREEZE: ruby_fl_type = 2048;
pub const ruby_fl_type_RUBY_FL_USER0: ruby_fl_type = 4096;
pub const ruby_fl_type_RUBY_FL_USER1: ruby_fl_type = 8192;
pub const ruby_fl_type_RUBY_FL_USER2: ruby_fl_type = 16384;
pub const ruby_fl_type_RUBY_FL_USER3: ruby_fl_type = 32768;
pub const ruby_fl_type_RUBY_FL_USER4: ruby_fl_type = 65536;
pub const ruby_fl_type_RUBY_FL_USER5: ruby_fl_type = 131072;
pub const ruby_fl_type_RUBY_FL_USER6: ruby_fl_type = 262144;
pub const ruby_fl_type_RUBY_FL_USER7: ruby_fl_type = 524288;
pub const ruby_fl_type_RUBY_FL_USER8: ruby_fl_type = 1048576;
pub const ruby_fl_type_RUBY_FL_USER9: ruby_fl_type = 2097152;
pub const ruby_fl_type_RUBY_FL_USER10: ruby_fl_type = 4194304;
pub const ruby_fl_type_RUBY_FL_USER11: ruby_fl_type = 8388608;
pub const ruby_fl_type_RUBY_FL_USER12: ruby_fl_type = 16777216;
pub const ruby_fl_type_RUBY_FL_USER13: ruby_fl_type = 33554432;
pub const ruby_fl_type_RUBY_FL_USER14: ruby_fl_type = 67108864;
pub const ruby_fl_type_RUBY_FL_USER15: ruby_fl_type = 134217728;
pub const ruby_fl_type_RUBY_FL_USER16: ruby_fl_type = 268435456;
pub const ruby_fl_type_RUBY_FL_USER17: ruby_fl_type = 536870912;
pub const ruby_fl_type_RUBY_FL_USER18: ruby_fl_type = 1073741824;
pub const ruby_fl_type_RUBY_FL_USER19: ruby_fl_type = -2147483648;
pub const ruby_fl_type_RUBY_ELTS_SHARED: ruby_fl_type = 16384;
pub const ruby_fl_type_RUBY_FL_SINGLETON: ruby_fl_type = 4096;
pub type ruby_fl_type = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString {
    pub basic: RBasic,
    pub as_: RString__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1 {
    pub heap: RString__bindgen_ty_1__bindgen_ty_1,
    pub ary: [::std::os::raw::c_char; 24usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RString__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_long,
    pub ptr: *mut ::std::os::raw::c_char,
    pub aux: RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub capa: ::std::os::raw::c_long,
    pub shared: VALUE,
}
#[test]
fn bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_capa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capa) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(capa)
            )
        );
    }
    test_field_capa();
    fn test_field_shared() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shared) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(shared)
            )
        );
    }
    test_field_shared();
}
impl ::std::fmt::Debug for RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
#[test]
fn bindgen_test_layout_RString__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RString__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(RString__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RString__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RString__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<RString__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RString__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
    fn test_field_ptr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<RString__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RString__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ptr)
            )
        );
    }
    test_field_ptr();
    fn test_field_aux() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<RString__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aux) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RString__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(aux)
            )
        );
    }
    test_field_aux();
}
impl ::std::fmt::Debug for RString__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RString__bindgen_ty_1__bindgen_ty_1 {{ len: {:?}, ptr: {:?}, aux: {:?} }}",
            self.len, self.ptr, self.aux
        )
    }
}
#[test]
fn bindgen_test_layout_RString__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RString__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(RString__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RString__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(RString__bindgen_ty_1))
    );
    fn test_field_heap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RString__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RString__bindgen_ty_1),
                "::",
                stringify!(heap)
            )
        );
    }
    test_field_heap();
    fn test_field_ary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RString__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ary) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RString__bindgen_ty_1),
                "::",
                stringify!(ary)
            )
        );
    }
    test_field_ary();
}
impl ::std::fmt::Debug for RString__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RString__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_RString() {
    assert_eq!(
        ::std::mem::size_of::<RString>(),
        40usize,
        concat!("Size of: ", stringify!(RString))
    );
    assert_eq!(
        ::std::mem::align_of::<RString>(),
        8usize,
        concat!("Alignment of ", stringify!(RString))
    );
    fn test_field_basic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RString>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RString),
                "::",
                stringify!(basic)
            )
        );
    }
    test_field_basic();
    fn test_field_as() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RString>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RString),
                "::",
                stringify!(as_)
            )
        );
    }
    test_field_as();
}
impl ::std::fmt::Debug for RString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RString {{ basic: {:?}, as: {:?} }}",
            self.basic, self.as_
        )
    }
}
pub type st_data_t = usize;
pub type st_index_t = st_data_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_hash_type {
    pub compare: ::std::option::Option<
        unsafe extern "C" fn(arg1: st_data_t, arg2: st_data_t) -> ::std::os::raw::c_int,
    >,
    pub hash: ::std::option::Option<unsafe extern "C" fn(arg1: st_data_t) -> st_index_t>,
}
#[test]
fn bindgen_test_layout_st_hash_type() {
    assert_eq!(
        ::std::mem::size_of::<st_hash_type>(),
        16usize,
        concat!("Size of: ", stringify!(st_hash_type))
    );
    assert_eq!(
        ::std::mem::align_of::<st_hash_type>(),
        8usize,
        concat!("Alignment of ", stringify!(st_hash_type))
    );
    fn test_field_compare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_hash_type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compare) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(st_hash_type),
                "::",
                stringify!(compare)
            )
        );
    }
    test_field_compare();
    fn test_field_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_hash_type>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hash) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(st_hash_type),
                "::",
                stringify!(hash)
            )
        );
    }
    test_field_hash();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct st_table {
    pub entry_power: ::std::os::raw::c_uchar,
    pub bin_power: ::std::os::raw::c_uchar,
    pub size_ind: ::std::os::raw::c_uchar,
    pub rebuilds_num: ::std::os::raw::c_uint,
    pub type_: *const st_hash_type,
    pub num_entries: st_index_t,
    pub bins: *mut st_index_t,
    pub entries_start: st_index_t,
    pub entries_bound: st_index_t,
    pub entries: *mut st_table_entry,
}
#[test]
fn bindgen_test_layout_st_table() {
    assert_eq!(
        ::std::mem::size_of::<st_table>(),
        56usize,
        concat!("Size of: ", stringify!(st_table))
    );
    assert_eq!(
        ::std::mem::align_of::<st_table>(),
        8usize,
        concat!("Alignment of ", stringify!(st_table))
    );
    fn test_field_entry_power() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry_power) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(entry_power)
            )
        );
    }
    test_field_entry_power();
    fn test_field_bin_power() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bin_power) as usize - ptr as usize
            },
            1usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(bin_power)
            )
        );
    }
    test_field_bin_power();
    fn test_field_size_ind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size_ind) as usize - ptr as usize
            },
            2usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(size_ind)
            )
        );
    }
    test_field_size_ind();
    fn test_field_rebuilds_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rebuilds_num) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(rebuilds_num)
            )
        );
    }
    test_field_rebuilds_num();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_num_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num_entries) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(num_entries)
            )
        );
    }
    test_field_num_entries();
    fn test_field_bins() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bins) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(bins)
            )
        );
    }
    test_field_bins();
    fn test_field_entries_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entries_start) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(entries_start)
            )
        );
    }
    test_field_entries_start();
    fn test_field_entries_bound() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entries_bound) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(entries_bound)
            )
        );
    }
    test_field_entries_bound();
    fn test_field_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<st_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(st_table),
                "::",
                stringify!(entries)
            )
        );
    }
    test_field_entries();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray {
    pub basic: RBasic,
    pub as_: RArray__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1 {
    pub heap: RArray__bindgen_ty_1__bindgen_ty_1,
    pub ary: [VALUE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RArray__bindgen_ty_1__bindgen_ty_1 {
    pub len: ::std::os::raw::c_long,
    pub aux: RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub ptr: *const VALUE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub capa: ::std::os::raw::c_long,
    pub shared_root: VALUE,
}
#[test]
fn bindgen_test_layout_RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_capa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).capa) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(capa)
            )
        );
    }
    test_field_capa();
    fn test_field_shared_root() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shared_root) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(shared_root)
            )
        );
    }
    test_field_shared_root();
}
impl ::std::fmt::Debug for RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {{ union }}"
        )
    }
}
#[test]
fn bindgen_test_layout_RArray__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RArray__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(RArray__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RArray__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(RArray__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_len() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<RArray__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(len)
            )
        );
    }
    test_field_len();
    fn test_field_aux() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<RArray__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aux) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(aux)
            )
        );
    }
    test_field_aux();
    fn test_field_ptr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<RArray__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(ptr)
            )
        );
    }
    test_field_ptr();
}
impl ::std::fmt::Debug for RArray__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RArray__bindgen_ty_1__bindgen_ty_1 {{ len: {:?}, aux: {:?}, ptr: {:?} }}",
            self.len, self.aux, self.ptr
        )
    }
}
#[test]
fn bindgen_test_layout_RArray__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<RArray__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(RArray__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<RArray__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(RArray__bindgen_ty_1))
    );
    fn test_field_heap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RArray__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heap) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray__bindgen_ty_1),
                "::",
                stringify!(heap)
            )
        );
    }
    test_field_heap();
    fn test_field_ary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RArray__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ary) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray__bindgen_ty_1),
                "::",
                stringify!(ary)
            )
        );
    }
    test_field_ary();
}
impl ::std::fmt::Debug for RArray__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "RArray__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_RArray() {
    assert_eq!(
        ::std::mem::size_of::<RArray>(),
        40usize,
        concat!("Size of: ", stringify!(RArray))
    );
    assert_eq!(
        ::std::mem::align_of::<RArray>(),
        8usize,
        concat!("Alignment of ", stringify!(RArray))
    );
    fn test_field_basic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).basic) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray),
                "::",
                stringify!(basic)
            )
        );
    }
    test_field_basic();
    fn test_field_as() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<RArray>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).as_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(RArray),
                "::",
                stringify!(as_)
            )
        );
    }
    test_field_as();
}
impl ::std::fmt::Debug for RArray {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "RArray {{ basic: {:?}, as: {:?} }}",
            self.basic, self.as_
        )
    }
}
pub type rb_event_flag_t = u32;
pub type rb_unblock_function_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
pub type rb_serial_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_callinfo {
    _unused: [u8; 0],
}
pub const method_missing_reason_MISSING_NOENTRY: method_missing_reason = 0;
pub const method_missing_reason_MISSING_PRIVATE: method_missing_reason = 1;
pub const method_missing_reason_MISSING_PROTECTED: method_missing_reason = 2;
pub const method_missing_reason_MISSING_FCALL: method_missing_reason = 4;
pub const method_missing_reason_MISSING_VCALL: method_missing_reason = 8;
pub const method_missing_reason_MISSING_SUPER: method_missing_reason = 16;
pub const method_missing_reason_MISSING_MISSING: method_missing_reason = 32;
pub const method_missing_reason_MISSING_NONE: method_missing_reason = 64;
pub type method_missing_reason = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_callcache {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_objspace {
    _unused: [u8; 0],
}
pub const imemo_type_imemo_env: imemo_type = 0;
pub const imemo_type_imemo_cref: imemo_type = 1;
pub const imemo_type_imemo_svar: imemo_type = 2;
pub const imemo_type_imemo_throw_data: imemo_type = 3;
pub const imemo_type_imemo_ifunc: imemo_type = 4;
pub const imemo_type_imemo_memo: imemo_type = 5;
pub const imemo_type_imemo_ment: imemo_type = 6;
pub const imemo_type_imemo_iseq: imemo_type = 7;
pub const imemo_type_imemo_tmpbuf: imemo_type = 8;
pub const imemo_type_imemo_ast: imemo_type = 9;
pub const imemo_type_imemo_parser_strterm: imemo_type = 10;
pub const imemo_type_imemo_callinfo: imemo_type = 11;
pub const imemo_type_imemo_callcache: imemo_type = 12;
pub const imemo_type_imemo_constcache: imemo_type = 13;
pub type imemo_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_svar {
    pub flags: VALUE,
    pub cref_or_me: VALUE,
    pub lastline: VALUE,
    pub backref: VALUE,
    pub others: VALUE,
}
#[test]
fn bindgen_test_layout_vm_svar() {
    assert_eq!(
        ::std::mem::size_of::<vm_svar>(),
        40usize,
        concat!("Size of: ", stringify!(vm_svar))
    );
    assert_eq!(
        ::std::mem::align_of::<vm_svar>(),
        8usize,
        concat!("Alignment of ", stringify!(vm_svar))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vm_svar>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_svar),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_cref_or_me() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vm_svar>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cref_or_me) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_svar),
                "::",
                stringify!(cref_or_me)
            )
        );
    }
    test_field_cref_or_me();
    fn test_field_lastline() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vm_svar>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lastline) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_svar),
                "::",
                stringify!(lastline)
            )
        );
    }
    test_field_lastline();
    fn test_field_backref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vm_svar>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backref) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_svar),
                "::",
                stringify!(backref)
            )
        );
    }
    test_field_backref();
    fn test_field_others() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<vm_svar>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).others) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(vm_svar),
                "::",
                stringify!(others)
            )
        );
    }
    test_field_others();
}
pub const rb_method_visibility_t_METHOD_VISI_UNDEF: rb_method_visibility_t = 0;
pub const rb_method_visibility_t_METHOD_VISI_PUBLIC: rb_method_visibility_t = 1;
pub const rb_method_visibility_t_METHOD_VISI_PRIVATE: rb_method_visibility_t = 2;
pub const rb_method_visibility_t_METHOD_VISI_PROTECTED: rb_method_visibility_t = 3;
pub const rb_method_visibility_t_METHOD_VISI_MASK: rb_method_visibility_t = 3;
pub type rb_method_visibility_t = ::std::os::raw::c_uint;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rb_scope_visi_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_rb_scope_visi_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_scope_visi_struct>(),
        4usize,
        concat!("Size of: ", stringify!(rb_scope_visi_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_scope_visi_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(rb_scope_visi_struct))
    );
}
impl rb_scope_visi_struct {
    #[inline]
    pub fn method_visi(&self) -> rb_method_visibility_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_method_visi(&mut self, val: rb_method_visibility_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn module_func(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_module_func(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        method_visi: rb_method_visibility_t,
        module_func: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let method_visi: u32 = unsafe { ::std::mem::transmute(method_visi) };
            method_visi as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let module_func: u32 = unsafe { ::std::mem::transmute(module_func) };
            module_func as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rb_scope_visibility_t = rb_scope_visi_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_cref_struct {
    pub flags: VALUE,
    pub refinements: VALUE,
    pub klass: VALUE,
    pub next: *mut rb_cref_struct,
    pub scope_visi: rb_scope_visibility_t,
}
#[test]
fn bindgen_test_layout_rb_cref_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_cref_struct>(),
        40usize,
        concat!("Size of: ", stringify!(rb_cref_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_cref_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_cref_struct))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_cref_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_cref_struct),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_refinements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_cref_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refinements) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_cref_struct),
                "::",
                stringify!(refinements)
            )
        );
    }
    test_field_refinements();
    fn test_field_klass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_cref_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).klass) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_cref_struct),
                "::",
                stringify!(klass)
            )
        );
    }
    test_field_klass();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_cref_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_cref_struct),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_scope_visi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_cref_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scope_visi) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_cref_struct),
                "::",
                stringify!(scope_visi)
            )
        );
    }
    test_field_scope_visi();
}
pub type rb_cref_t = rb_cref_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_entry_struct {
    pub flags: VALUE,
    pub defined_class: VALUE,
    pub def: *mut rb_method_definition_struct,
    pub called_id: ID,
    pub owner: VALUE,
}
#[test]
fn bindgen_test_layout_rb_method_entry_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_entry_struct>(),
        40usize,
        concat!("Size of: ", stringify!(rb_method_entry_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_entry_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_method_entry_struct))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_entry_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_entry_struct),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_defined_class() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_entry_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defined_class) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_entry_struct),
                "::",
                stringify!(defined_class)
            )
        );
    }
    test_field_defined_class();
    fn test_field_def() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_entry_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).def) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_entry_struct),
                "::",
                stringify!(def)
            )
        );
    }
    test_field_def();
    fn test_field_called_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_entry_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).called_id) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_entry_struct),
                "::",
                stringify!(called_id)
            )
        );
    }
    test_field_called_id();
    fn test_field_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_entry_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_entry_struct),
                "::",
                stringify!(owner)
            )
        );
    }
    test_field_owner();
}
pub const rb_method_type_t_VM_METHOD_TYPE_ISEQ: rb_method_type_t = 0;
pub const rb_method_type_t_VM_METHOD_TYPE_CFUNC: rb_method_type_t = 1;
pub const rb_method_type_t_VM_METHOD_TYPE_ATTRSET: rb_method_type_t = 2;
pub const rb_method_type_t_VM_METHOD_TYPE_IVAR: rb_method_type_t = 3;
pub const rb_method_type_t_VM_METHOD_TYPE_BMETHOD: rb_method_type_t = 4;
pub const rb_method_type_t_VM_METHOD_TYPE_ZSUPER: rb_method_type_t = 5;
pub const rb_method_type_t_VM_METHOD_TYPE_ALIAS: rb_method_type_t = 6;
pub const rb_method_type_t_VM_METHOD_TYPE_UNDEF: rb_method_type_t = 7;
pub const rb_method_type_t_VM_METHOD_TYPE_NOTIMPLEMENTED: rb_method_type_t = 8;
pub const rb_method_type_t_VM_METHOD_TYPE_OPTIMIZED: rb_method_type_t = 9;
pub const rb_method_type_t_VM_METHOD_TYPE_MISSING: rb_method_type_t = 10;
pub const rb_method_type_t_VM_METHOD_TYPE_REFINED: rb_method_type_t = 11;
pub type rb_method_type_t = ::std::os::raw::c_uint;
pub type rb_iseq_t = rb_iseq_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_iseq_struct {
    pub iseqptr: *mut rb_iseq_t,
    pub cref: *mut rb_cref_t,
}
#[test]
fn bindgen_test_layout_rb_method_iseq_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_iseq_struct>(),
        16usize,
        concat!("Size of: ", stringify!(rb_method_iseq_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_iseq_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_method_iseq_struct))
    );
    fn test_field_iseqptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_iseq_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iseqptr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_iseq_struct),
                "::",
                stringify!(iseqptr)
            )
        );
    }
    test_field_iseqptr();
    fn test_field_cref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_iseq_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cref) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_iseq_struct),
                "::",
                stringify!(cref)
            )
        );
    }
    test_field_cref();
}
pub type rb_method_iseq_t = rb_method_iseq_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_cfunc_struct {
    pub func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
    pub invoker: ::std::option::Option<
        unsafe extern "C" fn(
            recv: VALUE,
            argc: ::std::os::raw::c_int,
            argv: *const VALUE,
            func: ::std::option::Option<unsafe extern "C" fn() -> VALUE>,
        ) -> VALUE,
    >,
    pub argc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rb_method_cfunc_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_cfunc_struct>(),
        24usize,
        concat!("Size of: ", stringify!(rb_method_cfunc_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_cfunc_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_method_cfunc_struct))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_cfunc_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_cfunc_struct),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_invoker() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_cfunc_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).invoker) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_cfunc_struct),
                "::",
                stringify!(invoker)
            )
        );
    }
    test_field_invoker();
    fn test_field_argc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_cfunc_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_cfunc_struct),
                "::",
                stringify!(argc)
            )
        );
    }
    test_field_argc();
}
pub type rb_method_cfunc_t = rb_method_cfunc_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_attr_struct {
    pub id: ID,
    pub location: VALUE,
}
#[test]
fn bindgen_test_layout_rb_method_attr_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_attr_struct>(),
        16usize,
        concat!("Size of: ", stringify!(rb_method_attr_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_attr_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_method_attr_struct))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_attr_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_attr_struct),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_attr_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_attr_struct),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
}
pub type rb_method_attr_t = rb_method_attr_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_alias_struct {
    pub original_me: *mut rb_method_entry_struct,
}
#[test]
fn bindgen_test_layout_rb_method_alias_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_alias_struct>(),
        8usize,
        concat!("Size of: ", stringify!(rb_method_alias_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_alias_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_method_alias_struct))
    );
    fn test_field_original_me() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_alias_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).original_me) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_alias_struct),
                "::",
                stringify!(original_me)
            )
        );
    }
    test_field_original_me();
}
pub type rb_method_alias_t = rb_method_alias_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_refined_struct {
    pub orig_me: *mut rb_method_entry_struct,
    pub owner: VALUE,
}
#[test]
fn bindgen_test_layout_rb_method_refined_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_refined_struct>(),
        16usize,
        concat!("Size of: ", stringify!(rb_method_refined_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_refined_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_method_refined_struct))
    );
    fn test_field_orig_me() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_refined_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).orig_me) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_refined_struct),
                "::",
                stringify!(orig_me)
            )
        );
    }
    test_field_orig_me();
    fn test_field_owner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_refined_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).owner) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_refined_struct),
                "::",
                stringify!(owner)
            )
        );
    }
    test_field_owner();
}
pub type rb_method_refined_t = rb_method_refined_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_method_bmethod_struct {
    pub proc_: VALUE,
    pub hooks: *mut rb_hook_list_struct,
    pub defined_ractor: VALUE,
}
#[test]
fn bindgen_test_layout_rb_method_bmethod_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_bmethod_struct>(),
        24usize,
        concat!("Size of: ", stringify!(rb_method_bmethod_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_bmethod_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_method_bmethod_struct))
    );
    fn test_field_proc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_bmethod_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proc_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_bmethod_struct),
                "::",
                stringify!(proc_)
            )
        );
    }
    test_field_proc();
    fn test_field_hooks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_bmethod_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hooks) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_bmethod_struct),
                "::",
                stringify!(hooks)
            )
        );
    }
    test_field_hooks();
    fn test_field_defined_ractor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_bmethod_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defined_ractor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_bmethod_struct),
                "::",
                stringify!(defined_ractor)
            )
        );
    }
    test_field_defined_ractor();
}
pub type rb_method_bmethod_t = rb_method_bmethod_struct;
pub const method_optimized_type_OPTIMIZED_METHOD_TYPE_SEND: method_optimized_type = 0;
pub const method_optimized_type_OPTIMIZED_METHOD_TYPE_CALL: method_optimized_type = 1;
pub const method_optimized_type_OPTIMIZED_METHOD_TYPE_BLOCK_CALL: method_optimized_type = 2;
pub const method_optimized_type_OPTIMIZED_METHOD_TYPE__MAX: method_optimized_type = 3;
pub type method_optimized_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_method_definition_struct {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub body: rb_method_definition_struct__bindgen_ty_1,
    pub original_id: ID,
    pub method_serial: usize,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rb_method_definition_struct__bindgen_ty_1 {
    pub iseq: rb_method_iseq_t,
    pub cfunc: rb_method_cfunc_t,
    pub attr: rb_method_attr_t,
    pub alias: rb_method_alias_t,
    pub refined: rb_method_refined_t,
    pub bmethod: rb_method_bmethod_t,
    pub optimize_type: method_optimized_type,
}
#[test]
fn bindgen_test_layout_rb_method_definition_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_definition_struct__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rb_method_definition_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_definition_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_method_definition_struct__bindgen_ty_1)
        )
    );
    fn test_field_iseq() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_method_definition_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iseq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct__bindgen_ty_1),
                "::",
                stringify!(iseq)
            )
        );
    }
    test_field_iseq();
    fn test_field_cfunc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_method_definition_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cfunc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct__bindgen_ty_1),
                "::",
                stringify!(cfunc)
            )
        );
    }
    test_field_cfunc();
    fn test_field_attr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_method_definition_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).attr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct__bindgen_ty_1),
                "::",
                stringify!(attr)
            )
        );
    }
    test_field_attr();
    fn test_field_alias() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_method_definition_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alias) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct__bindgen_ty_1),
                "::",
                stringify!(alias)
            )
        );
    }
    test_field_alias();
    fn test_field_refined() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_method_definition_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).refined) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct__bindgen_ty_1),
                "::",
                stringify!(refined)
            )
        );
    }
    test_field_refined();
    fn test_field_bmethod() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_method_definition_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bmethod) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct__bindgen_ty_1),
                "::",
                stringify!(bmethod)
            )
        );
    }
    test_field_bmethod();
    fn test_field_optimize_type() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_method_definition_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).optimize_type) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct__bindgen_ty_1),
                "::",
                stringify!(optimize_type)
            )
        );
    }
    test_field_optimize_type();
}
impl ::std::fmt::Debug for rb_method_definition_struct__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "rb_method_definition_struct__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rb_method_definition_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_method_definition_struct>(),
        48usize,
        concat!("Size of: ", stringify!(rb_method_definition_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_method_definition_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_method_definition_struct))
    );
    fn test_field_body() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_definition_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct),
                "::",
                stringify!(body)
            )
        );
    }
    test_field_body();
    fn test_field_original_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_definition_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).original_id) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct),
                "::",
                stringify!(original_id)
            )
        );
    }
    test_field_original_id();
    fn test_field_method_serial() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_method_definition_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).method_serial) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_method_definition_struct),
                "::",
                stringify!(method_serial)
            )
        );
    }
    test_field_method_serial();
}
impl rb_method_definition_struct {
    #[inline]
    pub fn type_(&self) -> rb_method_type_t {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_type(&mut self, val: rb_method_type_t) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn alias_count(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_alias_count(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn complemented_count(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_complemented_count(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        type_: rb_method_type_t,
        alias_count: ::std::os::raw::c_int,
        complemented_count: ::std::os::raw::c_int,
    ) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let type_: u32 = unsafe { ::std::mem::transmute(type_) };
            type_ as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let alias_count: u32 = unsafe { ::std::mem::transmute(alias_count) };
            alias_count as u64
        });
        __bindgen_bitfield_unit.set(32usize, 28u8, {
            let complemented_count: u32 = unsafe { ::std::mem::transmute(complemented_count) };
            complemented_count as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_id_table {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_code_position_struct {
    pub lineno: ::std::os::raw::c_int,
    pub column: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rb_code_position_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_code_position_struct>(),
        8usize,
        concat!("Size of: ", stringify!(rb_code_position_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_code_position_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(rb_code_position_struct))
    );
    fn test_field_lineno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_code_position_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_code_position_struct),
                "::",
                stringify!(lineno)
            )
        );
    }
    test_field_lineno();
    fn test_field_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_code_position_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).column) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_code_position_struct),
                "::",
                stringify!(column)
            )
        );
    }
    test_field_column();
}
pub type rb_code_position_t = rb_code_position_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_code_location_struct {
    pub beg_pos: rb_code_position_t,
    pub end_pos: rb_code_position_t,
}
#[test]
fn bindgen_test_layout_rb_code_location_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_code_location_struct>(),
        16usize,
        concat!("Size of: ", stringify!(rb_code_location_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_code_location_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(rb_code_location_struct))
    );
    fn test_field_beg_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_code_location_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).beg_pos) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_code_location_struct),
                "::",
                stringify!(beg_pos)
            )
        );
    }
    test_field_beg_pos();
    fn test_field_end_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_code_location_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_pos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_code_location_struct),
                "::",
                stringify!(end_pos)
            )
        );
    }
    test_field_end_pos();
}
pub type rb_code_location_t = rb_code_location_struct;
pub type rb_atomic_t = ::std::os::raw::c_uint;
pub type rb_nativethread_id_t = pthread_t;
pub type rb_nativethread_lock_t = pthread_mutex_t;
pub type rb_nativethread_cond_t = pthread_cond_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct native_thread_data_struct {
    pub node: native_thread_data_struct__bindgen_ty_1,
    pub cond: native_thread_data_struct__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union native_thread_data_struct__bindgen_ty_1 {
    pub ubf: list_node,
    pub gvl: list_node,
}
#[test]
fn bindgen_test_layout_native_thread_data_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<native_thread_data_struct__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(native_thread_data_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<native_thread_data_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(native_thread_data_struct__bindgen_ty_1)
        )
    );
    fn test_field_ubf() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<native_thread_data_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ubf) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(native_thread_data_struct__bindgen_ty_1),
                "::",
                stringify!(ubf)
            )
        );
    }
    test_field_ubf();
    fn test_field_gvl() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<native_thread_data_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gvl) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(native_thread_data_struct__bindgen_ty_1),
                "::",
                stringify!(gvl)
            )
        );
    }
    test_field_gvl();
}
impl ::std::fmt::Debug for native_thread_data_struct__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "native_thread_data_struct__bindgen_ty_1 {{ union }}")
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union native_thread_data_struct__bindgen_ty_2 {
    pub intr: rb_nativethread_cond_t,
    pub gvlq: rb_nativethread_cond_t,
}
#[test]
fn bindgen_test_layout_native_thread_data_struct__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<native_thread_data_struct__bindgen_ty_2>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(native_thread_data_struct__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<native_thread_data_struct__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(native_thread_data_struct__bindgen_ty_2)
        )
    );
    fn test_field_intr() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<native_thread_data_struct__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).intr) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(native_thread_data_struct__bindgen_ty_2),
                "::",
                stringify!(intr)
            )
        );
    }
    test_field_intr();
    fn test_field_gvlq() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<native_thread_data_struct__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).gvlq) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(native_thread_data_struct__bindgen_ty_2),
                "::",
                stringify!(gvlq)
            )
        );
    }
    test_field_gvlq();
}
impl ::std::fmt::Debug for native_thread_data_struct__bindgen_ty_2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "native_thread_data_struct__bindgen_ty_2 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_native_thread_data_struct() {
    assert_eq!(
        ::std::mem::size_of::<native_thread_data_struct>(),
        64usize,
        concat!("Size of: ", stringify!(native_thread_data_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<native_thread_data_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(native_thread_data_struct))
    );
    fn test_field_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<native_thread_data_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(native_thread_data_struct),
                "::",
                stringify!(node)
            )
        );
    }
    test_field_node();
    fn test_field_cond() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<native_thread_data_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cond) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(native_thread_data_struct),
                "::",
                stringify!(cond)
            )
        );
    }
    test_field_cond();
}
impl ::std::fmt::Debug for native_thread_data_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "native_thread_data_struct {{ node: {:?}, cond: {:?} }}",
            self.node, self.cond
        )
    }
}
pub type native_thread_data_t = native_thread_data_struct;
pub type rb_snum_t = ::std::os::raw::c_long;
pub const ruby_tag_type_RUBY_TAG_NONE: ruby_tag_type = 0;
pub const ruby_tag_type_RUBY_TAG_RETURN: ruby_tag_type = 1;
pub const ruby_tag_type_RUBY_TAG_BREAK: ruby_tag_type = 2;
pub const ruby_tag_type_RUBY_TAG_NEXT: ruby_tag_type = 3;
pub const ruby_tag_type_RUBY_TAG_RETRY: ruby_tag_type = 4;
pub const ruby_tag_type_RUBY_TAG_REDO: ruby_tag_type = 5;
pub const ruby_tag_type_RUBY_TAG_RAISE: ruby_tag_type = 6;
pub const ruby_tag_type_RUBY_TAG_THROW: ruby_tag_type = 7;
pub const ruby_tag_type_RUBY_TAG_FATAL: ruby_tag_type = 8;
pub const ruby_tag_type_RUBY_TAG_MASK: ruby_tag_type = 15;
pub type ruby_tag_type = ::std::os::raw::c_uint;
pub type rb_compile_option_t = rb_compile_option_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_inline_constant_cache_entry {
    pub flags: VALUE,
    pub value: VALUE,
    pub ic_cref: *const rb_cref_t,
    pub ic_serial: rb_serial_t,
}
#[test]
fn bindgen_test_layout_iseq_inline_constant_cache_entry() {
    assert_eq!(
        ::std::mem::size_of::<iseq_inline_constant_cache_entry>(),
        32usize,
        concat!("Size of: ", stringify!(iseq_inline_constant_cache_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_inline_constant_cache_entry>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(iseq_inline_constant_cache_entry)
        )
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_constant_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_constant_cache_entry),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_constant_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_constant_cache_entry),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_ic_cref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_constant_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ic_cref) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_constant_cache_entry),
                "::",
                stringify!(ic_cref)
            )
        );
    }
    test_field_ic_cref();
    fn test_field_ic_serial() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_constant_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ic_serial) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_constant_cache_entry),
                "::",
                stringify!(ic_serial)
            )
        );
    }
    test_field_ic_serial();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_inline_constant_cache {
    pub entry: *mut iseq_inline_constant_cache_entry,
}
#[test]
fn bindgen_test_layout_iseq_inline_constant_cache() {
    assert_eq!(
        ::std::mem::size_of::<iseq_inline_constant_cache>(),
        8usize,
        concat!("Size of: ", stringify!(iseq_inline_constant_cache))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_inline_constant_cache>(),
        8usize,
        concat!("Alignment of ", stringify!(iseq_inline_constant_cache))
    );
    fn test_field_entry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_constant_cache>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_constant_cache),
                "::",
                stringify!(entry)
            )
        );
    }
    test_field_entry();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_inline_iv_cache_entry {
    pub entry: *mut rb_iv_index_tbl_entry,
}
#[test]
fn bindgen_test_layout_iseq_inline_iv_cache_entry() {
    assert_eq!(
        ::std::mem::size_of::<iseq_inline_iv_cache_entry>(),
        8usize,
        concat!("Size of: ", stringify!(iseq_inline_iv_cache_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_inline_iv_cache_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(iseq_inline_iv_cache_entry))
    );
    fn test_field_entry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_iv_cache_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_iv_cache_entry),
                "::",
                stringify!(entry)
            )
        );
    }
    test_field_entry();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union iseq_inline_storage_entry {
    pub once: iseq_inline_storage_entry__bindgen_ty_1,
    pub ic_cache: iseq_inline_constant_cache,
    pub iv_cache: iseq_inline_iv_cache_entry,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_inline_storage_entry__bindgen_ty_1 {
    pub running_thread: *mut rb_thread_struct,
    pub value: VALUE,
}
#[test]
fn bindgen_test_layout_iseq_inline_storage_entry__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<iseq_inline_storage_entry__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(iseq_inline_storage_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_inline_storage_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(iseq_inline_storage_entry__bindgen_ty_1)
        )
    );
    fn test_field_running_thread() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<iseq_inline_storage_entry__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).running_thread) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_storage_entry__bindgen_ty_1),
                "::",
                stringify!(running_thread)
            )
        );
    }
    test_field_running_thread();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<iseq_inline_storage_entry__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_storage_entry__bindgen_ty_1),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
}
#[test]
fn bindgen_test_layout_iseq_inline_storage_entry() {
    assert_eq!(
        ::std::mem::size_of::<iseq_inline_storage_entry>(),
        16usize,
        concat!("Size of: ", stringify!(iseq_inline_storage_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_inline_storage_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(iseq_inline_storage_entry))
    );
    fn test_field_once() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_storage_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).once) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_storage_entry),
                "::",
                stringify!(once)
            )
        );
    }
    test_field_once();
    fn test_field_ic_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_storage_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ic_cache) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_storage_entry),
                "::",
                stringify!(ic_cache)
            )
        );
    }
    test_field_ic_cache();
    fn test_field_iv_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_inline_storage_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iv_cache) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_inline_storage_entry),
                "::",
                stringify!(iv_cache)
            )
        );
    }
    test_field_iv_cache();
}
impl ::std::fmt::Debug for iseq_inline_storage_entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "iseq_inline_storage_entry {{ union }}")
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_calling_info {
    pub ci: *const rb_callinfo,
    pub cc: *const rb_callcache,
    pub block_handler: VALUE,
    pub recv: VALUE,
    pub argc: ::std::os::raw::c_int,
    pub kw_splat: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rb_calling_info() {
    assert_eq!(
        ::std::mem::size_of::<rb_calling_info>(),
        40usize,
        concat!("Size of: ", stringify!(rb_calling_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_calling_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_calling_info))
    );
    fn test_field_ci() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_calling_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ci) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_calling_info),
                "::",
                stringify!(ci)
            )
        );
    }
    test_field_ci();
    fn test_field_cc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_calling_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_calling_info),
                "::",
                stringify!(cc)
            )
        );
    }
    test_field_cc();
    fn test_field_block_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_calling_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_handler) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_calling_info),
                "::",
                stringify!(block_handler)
            )
        );
    }
    test_field_block_handler();
    fn test_field_recv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_calling_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).recv) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_calling_info),
                "::",
                stringify!(recv)
            )
        );
    }
    test_field_recv();
    fn test_field_argc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_calling_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_calling_info),
                "::",
                stringify!(argc)
            )
        );
    }
    test_field_argc();
    fn test_field_kw_splat() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_calling_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kw_splat) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_calling_info),
                "::",
                stringify!(kw_splat)
            )
        );
    }
    test_field_kw_splat();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_location_struct {
    pub pathobj: VALUE,
    pub base_label: VALUE,
    pub label: VALUE,
    pub first_lineno: VALUE,
    pub node_id: ::std::os::raw::c_int,
    pub code_location: rb_code_location_t,
}
#[test]
fn bindgen_test_layout_rb_iseq_location_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_location_struct>(),
        56usize,
        concat!("Size of: ", stringify!(rb_iseq_location_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_location_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_iseq_location_struct))
    );
    fn test_field_pathobj() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_location_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pathobj) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_location_struct),
                "::",
                stringify!(pathobj)
            )
        );
    }
    test_field_pathobj();
    fn test_field_base_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_location_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base_label) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_location_struct),
                "::",
                stringify!(base_label)
            )
        );
    }
    test_field_base_label();
    fn test_field_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_location_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).label) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_location_struct),
                "::",
                stringify!(label)
            )
        );
    }
    test_field_label();
    fn test_field_first_lineno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_location_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).first_lineno) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_location_struct),
                "::",
                stringify!(first_lineno)
            )
        );
    }
    test_field_first_lineno();
    fn test_field_node_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_location_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node_id) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_location_struct),
                "::",
                stringify!(node_id)
            )
        );
    }
    test_field_node_id();
    fn test_field_code_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_location_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).code_location) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_location_struct),
                "::",
                stringify!(code_location)
            )
        );
    }
    test_field_code_location();
}
pub type rb_iseq_location_t = rb_iseq_location_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_mjit_unit {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_constant_body {
    pub type_: rb_iseq_constant_body_iseq_type,
    pub iseq_size: ::std::os::raw::c_uint,
    pub iseq_encoded: *mut VALUE,
    pub param: rb_iseq_constant_body__bindgen_ty_1,
    pub location: rb_iseq_location_t,
    pub insns_info: rb_iseq_constant_body_iseq_insn_info,
    pub local_table: *const ID,
    pub catch_table: *mut iseq_catch_table,
    pub parent_iseq: *const rb_iseq_struct,
    pub local_iseq: *mut rb_iseq_struct,
    pub is_entries: *mut iseq_inline_storage_entry,
    pub call_data: *mut rb_call_data,
    pub variable: rb_iseq_constant_body__bindgen_ty_2,
    pub local_table_size: ::std::os::raw::c_uint,
    pub is_size: ::std::os::raw::c_uint,
    pub ci_size: ::std::os::raw::c_uint,
    pub stack_max: ::std::os::raw::c_uint,
    pub catch_except_p: ::std::os::raw::c_char,
    pub builtin_inline_p: bool,
    pub outer_variables: *mut rb_id_table,
    pub jit_func: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut rb_execution_context_struct,
            arg2: *mut rb_control_frame_struct,
        ) -> VALUE,
    >,
    pub total_calls: ::std::os::raw::c_ulong,
    pub jit_unit: *mut rb_mjit_unit,
}
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_TOP: rb_iseq_constant_body_iseq_type = 0;
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_METHOD: rb_iseq_constant_body_iseq_type = 1;
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_BLOCK: rb_iseq_constant_body_iseq_type = 2;
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_CLASS: rb_iseq_constant_body_iseq_type = 3;
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_RESCUE: rb_iseq_constant_body_iseq_type = 4;
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_ENSURE: rb_iseq_constant_body_iseq_type = 5;
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_EVAL: rb_iseq_constant_body_iseq_type = 6;
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_MAIN: rb_iseq_constant_body_iseq_type = 7;
pub const rb_iseq_constant_body_iseq_type_ISEQ_TYPE_PLAIN: rb_iseq_constant_body_iseq_type = 8;
pub type rb_iseq_constant_body_iseq_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_constant_body__bindgen_ty_1 {
    pub flags: rb_iseq_constant_body__bindgen_ty_1__bindgen_ty_1,
    pub size: ::std::os::raw::c_uint,
    pub lead_num: ::std::os::raw::c_int,
    pub opt_num: ::std::os::raw::c_int,
    pub rest_start: ::std::os::raw::c_int,
    pub post_start: ::std::os::raw::c_int,
    pub post_num: ::std::os::raw::c_int,
    pub block_start: ::std::os::raw::c_int,
    pub opt_table: *const VALUE,
    pub keyword: *const rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_constant_body__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u16,
}
#[test]
fn bindgen_test_layout_rb_iseq_constant_body__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_constant_body__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(rb_iseq_constant_body__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_constant_body__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(rb_iseq_constant_body__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl rb_iseq_constant_body__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn has_lead(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_lead(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_opt(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_opt(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_rest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_rest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_post(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_post(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_kw(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_kw(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_kwrest(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_kwrest(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn has_block(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_has_block(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ambiguous_param0(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ambiguous_param0(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn accepts_no_kwarg(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_accepts_no_kwarg(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ruby2_keywords(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ruby2_keywords(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        has_lead: ::std::os::raw::c_uint,
        has_opt: ::std::os::raw::c_uint,
        has_rest: ::std::os::raw::c_uint,
        has_post: ::std::os::raw::c_uint,
        has_kw: ::std::os::raw::c_uint,
        has_kwrest: ::std::os::raw::c_uint,
        has_block: ::std::os::raw::c_uint,
        ambiguous_param0: ::std::os::raw::c_uint,
        accepts_no_kwarg: ::std::os::raw::c_uint,
        ruby2_keywords: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let has_lead: u32 = unsafe { ::std::mem::transmute(has_lead) };
            has_lead as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let has_opt: u32 = unsafe { ::std::mem::transmute(has_opt) };
            has_opt as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let has_rest: u32 = unsafe { ::std::mem::transmute(has_rest) };
            has_rest as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let has_post: u32 = unsafe { ::std::mem::transmute(has_post) };
            has_post as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let has_kw: u32 = unsafe { ::std::mem::transmute(has_kw) };
            has_kw as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let has_kwrest: u32 = unsafe { ::std::mem::transmute(has_kwrest) };
            has_kwrest as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let has_block: u32 = unsafe { ::std::mem::transmute(has_block) };
            has_block as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let ambiguous_param0: u32 = unsafe { ::std::mem::transmute(ambiguous_param0) };
            ambiguous_param0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let accepts_no_kwarg: u32 = unsafe { ::std::mem::transmute(accepts_no_kwarg) };
            accepts_no_kwarg as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ruby2_keywords: u32 = unsafe { ::std::mem::transmute(ruby2_keywords) };
            ruby2_keywords as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword {
    pub num: ::std::os::raw::c_int,
    pub required_num: ::std::os::raw::c_int,
    pub bits_start: ::std::os::raw::c_int,
    pub rest_start: ::std::os::raw::c_int,
    pub table: *const ID,
    pub default_values: *mut VALUE,
}
#[test]
fn bindgen_test_layout_rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword)
        )
    );
    fn test_field_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword),
                "::",
                stringify!(num)
            )
        );
    }
    test_field_num();
    fn test_field_required_num() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).required_num) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword),
                "::",
                stringify!(required_num)
            )
        );
    }
    test_field_required_num();
    fn test_field_bits_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bits_start) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword),
                "::",
                stringify!(bits_start)
            )
        );
    }
    test_field_bits_start();
    fn test_field_rest_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rest_start) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword),
                "::",
                stringify!(rest_start)
            )
        );
    }
    test_field_rest_start();
    fn test_field_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).table) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword),
                "::",
                stringify!(table)
            )
        );
    }
    test_field_table();
    fn test_field_default_values() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_values) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1_rb_iseq_param_keyword),
                "::",
                stringify!(default_values)
            )
        );
    }
    test_field_default_values();
}
#[test]
fn bindgen_test_layout_rb_iseq_constant_body__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_constant_body__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(rb_iseq_constant_body__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_constant_body__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_iseq_constant_body__bindgen_ty_1)
        )
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_lead_num() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lead_num) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(lead_num)
            )
        );
    }
    test_field_lead_num();
    fn test_field_opt_num() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opt_num) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(opt_num)
            )
        );
    }
    test_field_opt_num();
    fn test_field_rest_start() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rest_start) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(rest_start)
            )
        );
    }
    test_field_rest_start();
    fn test_field_post_start() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).post_start) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(post_start)
            )
        );
    }
    test_field_post_start();
    fn test_field_post_num() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).post_num) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(post_num)
            )
        );
    }
    test_field_post_num();
    fn test_field_block_start() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_start) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(block_start)
            )
        );
    }
    test_field_block_start();
    fn test_field_opt_table() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opt_table) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(opt_table)
            )
        );
    }
    test_field_opt_table();
    fn test_field_keyword() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keyword) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_1),
                "::",
                stringify!(keyword)
            )
        );
    }
    test_field_keyword();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_constant_body_iseq_insn_info {
    pub body: *const iseq_insn_info_entry,
    pub positions: *mut ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub succ_index_table: *mut succ_index_table,
}
#[test]
fn bindgen_test_layout_rb_iseq_constant_body_iseq_insn_info() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_constant_body_iseq_insn_info>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(rb_iseq_constant_body_iseq_insn_info)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_constant_body_iseq_insn_info>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_iseq_constant_body_iseq_insn_info)
        )
    );
    fn test_field_body() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body_iseq_insn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body_iseq_insn_info),
                "::",
                stringify!(body)
            )
        );
    }
    test_field_body();
    fn test_field_positions() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body_iseq_insn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).positions) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body_iseq_insn_info),
                "::",
                stringify!(positions)
            )
        );
    }
    test_field_positions();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body_iseq_insn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body_iseq_insn_info),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_succ_index_table() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body_iseq_insn_info>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).succ_index_table) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body_iseq_insn_info),
                "::",
                stringify!(succ_index_table)
            )
        );
    }
    test_field_succ_index_table();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_constant_body__bindgen_ty_2 {
    pub flip_count: rb_snum_t,
    pub coverage: VALUE,
    pub pc2branchindex: VALUE,
    pub original_iseq: *mut VALUE,
}
#[test]
fn bindgen_test_layout_rb_iseq_constant_body__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_constant_body__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(rb_iseq_constant_body__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_constant_body__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_iseq_constant_body__bindgen_ty_2)
        )
    );
    fn test_field_flip_count() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flip_count) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_2),
                "::",
                stringify!(flip_count)
            )
        );
    }
    test_field_flip_count();
    fn test_field_coverage() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverage) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_2),
                "::",
                stringify!(coverage)
            )
        );
    }
    test_field_coverage();
    fn test_field_pc2branchindex() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc2branchindex) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_2),
                "::",
                stringify!(pc2branchindex)
            )
        );
    }
    test_field_pc2branchindex();
    fn test_field_original_iseq() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_constant_body__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).original_iseq) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body__bindgen_ty_2),
                "::",
                stringify!(original_iseq)
            )
        );
    }
    test_field_original_iseq();
}
#[test]
fn bindgen_test_layout_rb_iseq_constant_body() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_constant_body>(),
        288usize,
        concat!("Size of: ", stringify!(rb_iseq_constant_body))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_constant_body>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_iseq_constant_body))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_iseq_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iseq_size) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(iseq_size)
            )
        );
    }
    test_field_iseq_size();
    fn test_field_iseq_encoded() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iseq_encoded) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(iseq_encoded)
            )
        );
    }
    test_field_iseq_encoded();
    fn test_field_param() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).param) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(param)
            )
        );
    }
    test_field_param();
    fn test_field_location() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).location) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(location)
            )
        );
    }
    test_field_location();
    fn test_field_insns_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).insns_info) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(insns_info)
            )
        );
    }
    test_field_insns_info();
    fn test_field_local_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_table) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(local_table)
            )
        );
    }
    test_field_local_table();
    fn test_field_catch_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).catch_table) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(catch_table)
            )
        );
    }
    test_field_catch_table();
    fn test_field_parent_iseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent_iseq) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(parent_iseq)
            )
        );
    }
    test_field_parent_iseq();
    fn test_field_local_iseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_iseq) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(local_iseq)
            )
        );
    }
    test_field_local_iseq();
    fn test_field_is_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_entries) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(is_entries)
            )
        );
    }
    test_field_is_entries();
    fn test_field_call_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).call_data) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(call_data)
            )
        );
    }
    test_field_call_data();
    fn test_field_variable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).variable) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(variable)
            )
        );
    }
    test_field_variable();
    fn test_field_local_table_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_table_size) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(local_table_size)
            )
        );
    }
    test_field_local_table_size();
    fn test_field_is_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_size) as usize - ptr as usize
            },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(is_size)
            )
        );
    }
    test_field_is_size();
    fn test_field_ci_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ci_size) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(ci_size)
            )
        );
    }
    test_field_ci_size();
    fn test_field_stack_max() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack_max) as usize - ptr as usize
            },
            244usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(stack_max)
            )
        );
    }
    test_field_stack_max();
    fn test_field_catch_except_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).catch_except_p) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(catch_except_p)
            )
        );
    }
    test_field_catch_except_p();
    fn test_field_builtin_inline_p() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).builtin_inline_p) as usize - ptr as usize
            },
            249usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(builtin_inline_p)
            )
        );
    }
    test_field_builtin_inline_p();
    fn test_field_outer_variables() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).outer_variables) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(outer_variables)
            )
        );
    }
    test_field_outer_variables();
    fn test_field_jit_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).jit_func) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(jit_func)
            )
        );
    }
    test_field_jit_func();
    fn test_field_total_calls() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).total_calls) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(total_calls)
            )
        );
    }
    test_field_total_calls();
    fn test_field_jit_unit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_constant_body>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).jit_unit) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_constant_body),
                "::",
                stringify!(jit_unit)
            )
        );
    }
    test_field_jit_unit();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_iseq_struct {
    pub flags: VALUE,
    pub wrapper: VALUE,
    pub body: *mut rb_iseq_constant_body,
    pub aux: rb_iseq_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rb_iseq_struct__bindgen_ty_1 {
    pub compile_data: *mut iseq_compile_data,
    pub loader: rb_iseq_struct__bindgen_ty_1__bindgen_ty_1,
    pub exec: rb_iseq_struct__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_struct__bindgen_ty_1__bindgen_ty_1 {
    pub obj: VALUE,
    pub index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rb_iseq_struct__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_struct__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(rb_iseq_struct__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_struct__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_iseq_struct__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_obj() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).obj) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(obj)
            )
        );
    }
    test_field_obj();
    fn test_field_index() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).index) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(index)
            )
        );
    }
    test_field_index();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iseq_struct__bindgen_ty_1__bindgen_ty_2 {
    pub local_hooks: *mut rb_hook_list_struct,
    pub global_trace_events: rb_event_flag_t,
}
#[test]
fn bindgen_test_layout_rb_iseq_struct__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_struct__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(rb_iseq_struct__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_struct__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_iseq_struct__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_local_hooks() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_struct__bindgen_ty_1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_hooks) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(local_hooks)
            )
        );
    }
    test_field_local_hooks();
    fn test_field_global_trace_events() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_iseq_struct__bindgen_ty_1__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).global_trace_events) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(global_trace_events)
            )
        );
    }
    test_field_global_trace_events();
}
#[test]
fn bindgen_test_layout_rb_iseq_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_struct__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rb_iseq_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_iseq_struct__bindgen_ty_1))
    );
    fn test_field_compile_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).compile_data) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct__bindgen_ty_1),
                "::",
                stringify!(compile_data)
            )
        );
    }
    test_field_compile_data();
    fn test_field_loader() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loader) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct__bindgen_ty_1),
                "::",
                stringify!(loader)
            )
        );
    }
    test_field_loader();
    fn test_field_exec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct__bindgen_ty_1),
                "::",
                stringify!(exec)
            )
        );
    }
    test_field_exec();
}
impl ::std::fmt::Debug for rb_iseq_struct__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "rb_iseq_struct__bindgen_ty_1 {{ union }}")
    }
}
#[test]
fn bindgen_test_layout_rb_iseq_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_iseq_struct>(),
        40usize,
        concat!("Size of: ", stringify!(rb_iseq_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_iseq_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_iseq_struct))
    );
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_wrapper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).wrapper) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct),
                "::",
                stringify!(wrapper)
            )
        );
    }
    test_field_wrapper();
    fn test_field_body() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).body) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct),
                "::",
                stringify!(body)
            )
        );
    }
    test_field_body();
    fn test_field_aux() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_iseq_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).aux) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_iseq_struct),
                "::",
                stringify!(aux)
            )
        );
    }
    test_field_aux();
}
impl ::std::fmt::Debug for rb_iseq_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(
            f,
            "rb_iseq_struct {{ flags: {:?}, wrapper: {:?}, body: {:?}, aux: {:?} }}",
            self.flags, self.wrapper, self.body, self.aux
        )
    }
}
pub type rb_vm_at_exit_func = ::std::option::Option<unsafe extern "C" fn(arg1: *mut rb_vm_struct)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_at_exit_list {
    pub func: rb_vm_at_exit_func,
    pub next: *mut rb_at_exit_list,
}
#[test]
fn bindgen_test_layout_rb_at_exit_list() {
    assert_eq!(
        ::std::mem::size_of::<rb_at_exit_list>(),
        16usize,
        concat!("Size of: ", stringify!(rb_at_exit_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_at_exit_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_at_exit_list))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_at_exit_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_at_exit_list),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_at_exit_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_at_exit_list),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_hook_list_struct {
    pub hooks: *mut rb_event_hook_struct,
    pub events: rb_event_flag_t,
    pub need_clean: ::std::os::raw::c_uint,
    pub running: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rb_hook_list_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_hook_list_struct>(),
        24usize,
        concat!("Size of: ", stringify!(rb_hook_list_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_hook_list_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_hook_list_struct))
    );
    fn test_field_hooks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_hook_list_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hooks) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_hook_list_struct),
                "::",
                stringify!(hooks)
            )
        );
    }
    test_field_hooks();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_hook_list_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_hook_list_struct),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
    fn test_field_need_clean() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_hook_list_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).need_clean) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_hook_list_struct),
                "::",
                stringify!(need_clean)
            )
        );
    }
    test_field_need_clean();
    fn test_field_running() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_hook_list_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).running) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_hook_list_struct),
                "::",
                stringify!(running)
            )
        );
    }
    test_field_running();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_builtin_function {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_vm_struct {
    pub self_: VALUE,
    pub ractor: rb_vm_struct__bindgen_ty_1,
    pub main_altstack: *mut ::std::os::raw::c_void,
    pub fork_gen: rb_serial_t,
    pub waitpid_lock: rb_nativethread_lock_t,
    pub waiting_pids: list_head,
    pub waiting_grps: list_head,
    pub waiting_fds: list_head,
    pub ubf_async_safe: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub mark_object_ary: VALUE,
    pub special_exceptions: [VALUE; 5usize],
    pub top_self: VALUE,
    pub load_path: VALUE,
    pub load_path_snapshot: VALUE,
    pub load_path_check_cache: VALUE,
    pub expanded_load_path: VALUE,
    pub loaded_features: VALUE,
    pub loaded_features_snapshot: VALUE,
    pub loaded_features_index: *mut st_table,
    pub loading_table: *mut st_table,
    pub trap_list: rb_vm_struct__bindgen_ty_2,
    pub ensure_rollback_table: *mut st_table,
    pub postponed_job_buffer: *mut rb_postponed_job_struct,
    pub postponed_job_index: rb_atomic_t,
    pub src_encoding_index: ::std::os::raw::c_int,
    pub workqueue: list_head,
    pub workqueue_lock: rb_nativethread_lock_t,
    pub orig_progname: VALUE,
    pub progname: VALUE,
    pub coverages: VALUE,
    pub coverage_mode: ::std::os::raw::c_int,
    pub defined_module_hash: *mut st_table,
    pub objspace: *mut rb_objspace,
    pub at_exit: *mut rb_at_exit_list,
    pub defined_strings: *mut VALUE,
    pub frozen_strings: *mut st_table,
    pub builtin_function_table: *const rb_builtin_function,
    pub builtin_inline_index: ::std::os::raw::c_int,
    pub negative_cme_table: *mut rb_id_table,
    pub global_cc_cache_table: [*const rb_callcache; 1023usize],
    pub default_params: rb_vm_struct__bindgen_ty_3,
    pub redefined_flag: [::std::os::raw::c_short; 29usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_vm_struct__bindgen_ty_1 {
    pub set: list_head,
    pub cnt: ::std::os::raw::c_uint,
    pub blocking_cnt: ::std::os::raw::c_uint,
    pub main_ractor: *mut rb_ractor_struct,
    pub main_thread: *mut rb_thread_struct,
    pub sync: rb_vm_struct__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_vm_struct__bindgen_ty_1__bindgen_ty_1 {
    pub lock: rb_nativethread_lock_t,
    pub lock_owner: *mut rb_ractor_struct,
    pub lock_rec: ::std::os::raw::c_uint,
    pub barrier_waiting: bool,
    pub barrier_cnt: ::std::os::raw::c_uint,
    pub barrier_cond: rb_nativethread_cond_t,
    pub terminate_cond: rb_nativethread_cond_t,
    pub terminate_waiting: bool,
}
#[test]
fn bindgen_test_layout_rb_vm_struct__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>(),
        168usize,
        concat!(
            "Size of: ",
            stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_lock() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(lock)
            )
        );
    }
    test_field_lock();
    fn test_field_lock_owner() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_owner) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(lock_owner)
            )
        );
    }
    test_field_lock_owner();
    fn test_field_lock_rec() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_rec) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(lock_rec)
            )
        );
    }
    test_field_lock_rec();
    fn test_field_barrier_waiting() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).barrier_waiting) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(barrier_waiting)
            )
        );
    }
    test_field_barrier_waiting();
    fn test_field_barrier_cnt() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).barrier_cnt) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(barrier_cnt)
            )
        );
    }
    test_field_barrier_cnt();
    fn test_field_barrier_cond() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).barrier_cond) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(barrier_cond)
            )
        );
    }
    test_field_barrier_cond();
    fn test_field_terminate_cond() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).terminate_cond) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(terminate_cond)
            )
        );
    }
    test_field_terminate_cond();
    fn test_field_terminate_waiting() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).terminate_waiting) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(terminate_waiting)
            )
        );
    }
    test_field_terminate_waiting();
}
impl ::std::fmt::Debug for rb_vm_struct__bindgen_ty_1__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rb_vm_struct__bindgen_ty_1__bindgen_ty_1 {{ lock: {:?}, lock_owner: {:?}, lock_rec: {:?}, barrier_waiting: {:?}, barrier_cnt: {:?}, barrier_cond: {:?}, terminate_cond: {:?}, terminate_waiting: {:?} }}" , self . lock , self . lock_owner , self . lock_rec , self . barrier_waiting , self . barrier_cnt , self . barrier_cond , self . terminate_cond , self . terminate_waiting)
    }
}
#[test]
fn bindgen_test_layout_rb_vm_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_vm_struct__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(rb_vm_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_vm_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_vm_struct__bindgen_ty_1))
    );
    fn test_field_set() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1),
                "::",
                stringify!(set)
            )
        );
    }
    test_field_set();
    fn test_field_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cnt) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1),
                "::",
                stringify!(cnt)
            )
        );
    }
    test_field_cnt();
    fn test_field_blocking_cnt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blocking_cnt) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1),
                "::",
                stringify!(blocking_cnt)
            )
        );
    }
    test_field_blocking_cnt();
    fn test_field_main_ractor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).main_ractor) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1),
                "::",
                stringify!(main_ractor)
            )
        );
    }
    test_field_main_ractor();
    fn test_field_main_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).main_thread) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1),
                "::",
                stringify!(main_thread)
            )
        );
    }
    test_field_main_thread();
    fn test_field_sync() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sync) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_1),
                "::",
                stringify!(sync)
            )
        );
    }
    test_field_sync();
}
impl ::std::fmt::Debug for rb_vm_struct__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rb_vm_struct__bindgen_ty_1 {{ set: {:?}, cnt: {:?}, blocking_cnt: {:?}, main_ractor: {:?}, main_thread: {:?}, sync: {:?} }}" , self . set , self . cnt , self . blocking_cnt , self . main_ractor , self . main_thread , self . sync)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_vm_struct__bindgen_ty_2 {
    pub cmd: [VALUE; 65usize],
}
#[test]
fn bindgen_test_layout_rb_vm_struct__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rb_vm_struct__bindgen_ty_2>(),
        520usize,
        concat!("Size of: ", stringify!(rb_vm_struct__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_vm_struct__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_vm_struct__bindgen_ty_2))
    );
    fn test_field_cmd() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cmd) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_2),
                "::",
                stringify!(cmd)
            )
        );
    }
    test_field_cmd();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_vm_struct__bindgen_ty_3 {
    pub thread_vm_stack_size: size_t,
    pub thread_machine_stack_size: size_t,
    pub fiber_vm_stack_size: size_t,
    pub fiber_machine_stack_size: size_t,
}
#[test]
fn bindgen_test_layout_rb_vm_struct__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rb_vm_struct__bindgen_ty_3>(),
        32usize,
        concat!("Size of: ", stringify!(rb_vm_struct__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_vm_struct__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_vm_struct__bindgen_ty_3))
    );
    fn test_field_thread_vm_stack_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_vm_stack_size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_3),
                "::",
                stringify!(thread_vm_stack_size)
            )
        );
    }
    test_field_thread_vm_stack_size();
    fn test_field_thread_machine_stack_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_machine_stack_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_3),
                "::",
                stringify!(thread_machine_stack_size)
            )
        );
    }
    test_field_thread_machine_stack_size();
    fn test_field_fiber_vm_stack_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fiber_vm_stack_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_3),
                "::",
                stringify!(fiber_vm_stack_size)
            )
        );
    }
    test_field_fiber_vm_stack_size();
    fn test_field_fiber_machine_stack_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct__bindgen_ty_3>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fiber_machine_stack_size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct__bindgen_ty_3),
                "::",
                stringify!(fiber_machine_stack_size)
            )
        );
    }
    test_field_fiber_machine_stack_size();
}
#[test]
fn bindgen_test_layout_rb_vm_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_vm_struct>(),
        9424usize,
        concat!("Size of: ", stringify!(rb_vm_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_vm_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_vm_struct))
    );
    fn test_field_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(self_)
            )
        );
    }
    test_field_self();
    fn test_field_ractor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ractor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(ractor)
            )
        );
    }
    test_field_ractor();
    fn test_field_main_altstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).main_altstack) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(main_altstack)
            )
        );
    }
    test_field_main_altstack();
    fn test_field_fork_gen() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fork_gen) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(fork_gen)
            )
        );
    }
    test_field_fork_gen();
    fn test_field_waitpid_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waitpid_lock) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(waitpid_lock)
            )
        );
    }
    test_field_waitpid_lock();
    fn test_field_waiting_pids() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waiting_pids) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(waiting_pids)
            )
        );
    }
    test_field_waiting_pids();
    fn test_field_waiting_grps() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waiting_grps) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(waiting_grps)
            )
        );
    }
    test_field_waiting_grps();
    fn test_field_waiting_fds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).waiting_fds) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(waiting_fds)
            )
        );
    }
    test_field_waiting_fds();
    fn test_field_ubf_async_safe() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ubf_async_safe) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(ubf_async_safe)
            )
        );
    }
    test_field_ubf_async_safe();
    fn test_field_mark_object_ary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mark_object_ary) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(mark_object_ary)
            )
        );
    }
    test_field_mark_object_ary();
    fn test_field_special_exceptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).special_exceptions) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(special_exceptions)
            )
        );
    }
    test_field_special_exceptions();
    fn test_field_top_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top_self) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(top_self)
            )
        );
    }
    test_field_top_self();
    fn test_field_load_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).load_path) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(load_path)
            )
        );
    }
    test_field_load_path();
    fn test_field_load_path_snapshot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).load_path_snapshot) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(load_path_snapshot)
            )
        );
    }
    test_field_load_path_snapshot();
    fn test_field_load_path_check_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).load_path_check_cache) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(load_path_check_cache)
            )
        );
    }
    test_field_load_path_check_cache();
    fn test_field_expanded_load_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).expanded_load_path) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(expanded_load_path)
            )
        );
    }
    test_field_expanded_load_path();
    fn test_field_loaded_features() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loaded_features) as usize - ptr as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(loaded_features)
            )
        );
    }
    test_field_loaded_features();
    fn test_field_loaded_features_snapshot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loaded_features_snapshot) as usize - ptr as usize
            },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(loaded_features_snapshot)
            )
        );
    }
    test_field_loaded_features_snapshot();
    fn test_field_loaded_features_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loaded_features_index) as usize - ptr as usize
            },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(loaded_features_index)
            )
        );
    }
    test_field_loaded_features_index();
    fn test_field_loading_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loading_table) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(loading_table)
            )
        );
    }
    test_field_loading_table();
    fn test_field_trap_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trap_list) as usize - ptr as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(trap_list)
            )
        );
    }
    test_field_trap_list();
    fn test_field_ensure_rollback_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ensure_rollback_table) as usize - ptr as usize
            },
            968usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(ensure_rollback_table)
            )
        );
    }
    test_field_ensure_rollback_table();
    fn test_field_postponed_job_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).postponed_job_buffer) as usize - ptr as usize
            },
            976usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(postponed_job_buffer)
            )
        );
    }
    test_field_postponed_job_buffer();
    fn test_field_postponed_job_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).postponed_job_index) as usize - ptr as usize
            },
            984usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(postponed_job_index)
            )
        );
    }
    test_field_postponed_job_index();
    fn test_field_src_encoding_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).src_encoding_index) as usize - ptr as usize
            },
            988usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(src_encoding_index)
            )
        );
    }
    test_field_src_encoding_index();
    fn test_field_workqueue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).workqueue) as usize - ptr as usize
            },
            992usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(workqueue)
            )
        );
    }
    test_field_workqueue();
    fn test_field_workqueue_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).workqueue_lock) as usize - ptr as usize
            },
            1008usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(workqueue_lock)
            )
        );
    }
    test_field_workqueue_lock();
    fn test_field_orig_progname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).orig_progname) as usize - ptr as usize
            },
            1048usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(orig_progname)
            )
        );
    }
    test_field_orig_progname();
    fn test_field_progname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).progname) as usize - ptr as usize
            },
            1056usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(progname)
            )
        );
    }
    test_field_progname();
    fn test_field_coverages() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverages) as usize - ptr as usize
            },
            1064usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(coverages)
            )
        );
    }
    test_field_coverages();
    fn test_field_coverage_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).coverage_mode) as usize - ptr as usize
            },
            1072usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(coverage_mode)
            )
        );
    }
    test_field_coverage_mode();
    fn test_field_defined_module_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defined_module_hash) as usize - ptr as usize
            },
            1080usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(defined_module_hash)
            )
        );
    }
    test_field_defined_module_hash();
    fn test_field_objspace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).objspace) as usize - ptr as usize
            },
            1088usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(objspace)
            )
        );
    }
    test_field_objspace();
    fn test_field_at_exit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).at_exit) as usize - ptr as usize
            },
            1096usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(at_exit)
            )
        );
    }
    test_field_at_exit();
    fn test_field_defined_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).defined_strings) as usize - ptr as usize
            },
            1104usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(defined_strings)
            )
        );
    }
    test_field_defined_strings();
    fn test_field_frozen_strings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frozen_strings) as usize - ptr as usize
            },
            1112usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(frozen_strings)
            )
        );
    }
    test_field_frozen_strings();
    fn test_field_builtin_function_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).builtin_function_table) as usize - ptr as usize
            },
            1120usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(builtin_function_table)
            )
        );
    }
    test_field_builtin_function_table();
    fn test_field_builtin_inline_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).builtin_inline_index) as usize - ptr as usize
            },
            1128usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(builtin_inline_index)
            )
        );
    }
    test_field_builtin_inline_index();
    fn test_field_negative_cme_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).negative_cme_table) as usize - ptr as usize
            },
            1136usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(negative_cme_table)
            )
        );
    }
    test_field_negative_cme_table();
    fn test_field_global_cc_cache_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).global_cc_cache_table) as usize - ptr as usize
            },
            1144usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(global_cc_cache_table)
            )
        );
    }
    test_field_global_cc_cache_table();
    fn test_field_default_params() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_params) as usize - ptr as usize
            },
            9328usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(default_params)
            )
        );
    }
    test_field_default_params();
    fn test_field_redefined_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).redefined_flag) as usize - ptr as usize
            },
            9360usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_struct),
                "::",
                stringify!(redefined_flag)
            )
        );
    }
    test_field_redefined_flag();
}
impl ::std::fmt::Debug for rb_vm_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rb_vm_struct {{ self: {:?}, ractor: {:?}, main_altstack: {:?}, fork_gen: {:?}, waitpid_lock: {:?}, waiting_pids: {:?}, waiting_grps: {:?}, waiting_fds: {:?}, ubf_async_safe: {:?}, running : {:?}, thread_abort_on_exception : {:?}, thread_report_on_exception : {:?}, thread_ignore_deadlock : {:?}, mark_object_ary: {:?}, special_exceptions: {:?}, top_self: {:?}, load_path: {:?}, load_path_snapshot: {:?}, load_path_check_cache: {:?}, expanded_load_path: {:?}, loaded_features: {:?}, loaded_features_snapshot: {:?}, loaded_features_index: {:?}, loading_table: {:?}, trap_list: {:?}, ensure_rollback_table: {:?}, postponed_job_buffer: {:?}, postponed_job_index: {:?}, src_encoding_index: {:?}, workqueue: {:?}, workqueue_lock: {:?}, orig_progname: {:?}, progname: {:?}, coverages: {:?}, coverage_mode: {:?}, defined_module_hash: {:?}, objspace: {:?}, at_exit: {:?}, defined_strings: {:?}, frozen_strings: {:?}, builtin_function_table: {:?}, builtin_inline_index: {:?}, negative_cme_table: {:?}, global_cc_cache_table: {:?}, default_params: {:?}, redefined_flag: {:?} }}" , self . self_ , self . ractor , self . main_altstack , self . fork_gen , self . waitpid_lock , self . waiting_pids , self . waiting_grps , self . waiting_fds , self . ubf_async_safe , self . running () , self . thread_abort_on_exception () , self . thread_report_on_exception () , self . thread_ignore_deadlock () , self . mark_object_ary , self . special_exceptions , self . top_self , self . load_path , self . load_path_snapshot , self . load_path_check_cache , self . expanded_load_path , self . loaded_features , self . loaded_features_snapshot , self . loaded_features_index , self . loading_table , self . trap_list , self . ensure_rollback_table , self . postponed_job_buffer , self . postponed_job_index , self . src_encoding_index , self . workqueue , self . workqueue_lock , self . orig_progname , self . progname , self . coverages , self . coverage_mode , self . defined_module_hash , self . objspace , self . at_exit , self . defined_strings , self . frozen_strings , self . builtin_function_table , self . builtin_inline_index , self . negative_cme_table , self . global_cc_cache_table , self . default_params , self . redefined_flag)
    }
}
impl rb_vm_struct {
    #[inline]
    pub fn running(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_running(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thread_abort_on_exception(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thread_abort_on_exception(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thread_report_on_exception(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thread_report_on_exception(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn thread_ignore_deadlock(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_thread_ignore_deadlock(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        running: ::std::os::raw::c_uint,
        thread_abort_on_exception: ::std::os::raw::c_uint,
        thread_report_on_exception: ::std::os::raw::c_uint,
        thread_ignore_deadlock: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let running: u32 = unsafe { ::std::mem::transmute(running) };
            running as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let thread_abort_on_exception: u32 =
                unsafe { ::std::mem::transmute(thread_abort_on_exception) };
            thread_abort_on_exception as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let thread_report_on_exception: u32 =
                unsafe { ::std::mem::transmute(thread_report_on_exception) };
            thread_report_on_exception as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let thread_ignore_deadlock: u32 =
                unsafe { ::std::mem::transmute(thread_ignore_deadlock) };
            thread_ignore_deadlock as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rb_vm_t = rb_vm_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_control_frame_struct {
    pub pc: *const VALUE,
    pub sp: *mut VALUE,
    pub iseq: *const rb_iseq_t,
    pub self_: VALUE,
    pub ep: *const VALUE,
    pub block_code: *const ::std::os::raw::c_void,
    pub __bp__: *mut VALUE,
}
#[test]
fn bindgen_test_layout_rb_control_frame_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_control_frame_struct>(),
        56usize,
        concat!("Size of: ", stringify!(rb_control_frame_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_control_frame_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_control_frame_struct))
    );
    fn test_field_pc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_control_frame_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_control_frame_struct),
                "::",
                stringify!(pc)
            )
        );
    }
    test_field_pc();
    fn test_field_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_control_frame_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_control_frame_struct),
                "::",
                stringify!(sp)
            )
        );
    }
    test_field_sp();
    fn test_field_iseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_control_frame_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iseq) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_control_frame_struct),
                "::",
                stringify!(iseq)
            )
        );
    }
    test_field_iseq();
    fn test_field_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_control_frame_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_control_frame_struct),
                "::",
                stringify!(self_)
            )
        );
    }
    test_field_self();
    fn test_field_ep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_control_frame_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ep) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_control_frame_struct),
                "::",
                stringify!(ep)
            )
        );
    }
    test_field_ep();
    fn test_field_block_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_control_frame_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).block_code) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_control_frame_struct),
                "::",
                stringify!(block_code)
            )
        );
    }
    test_field_block_code();
    fn test_field___bp__() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_control_frame_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).__bp__) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_control_frame_struct),
                "::",
                stringify!(__bp__)
            )
        );
    }
    test_field___bp__();
}
pub type rb_control_frame_t = rb_control_frame_struct;
pub const rb_thread_status_THREAD_RUNNABLE: rb_thread_status = 0;
pub const rb_thread_status_THREAD_STOPPED: rb_thread_status = 1;
pub const rb_thread_status_THREAD_STOPPED_FOREVER: rb_thread_status = 2;
pub const rb_thread_status_THREAD_KILLED: rb_thread_status = 3;
pub type rb_thread_status = ::std::os::raw::c_uint;
pub type rb_jmpbuf_t = sigjmp_buf;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_vm_tag {
    pub tag: VALUE,
    pub retval: VALUE,
    pub buf: rb_jmpbuf_t,
    pub prev: *mut rb_vm_tag,
    pub state: ruby_tag_type,
    pub lock_rec: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_rb_vm_tag() {
    assert_eq!(
        ::std::mem::size_of::<rb_vm_tag>(),
        232usize,
        concat!("Size of: ", stringify!(rb_vm_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_vm_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_vm_tag))
    );
    fn test_field_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_tag),
                "::",
                stringify!(tag)
            )
        );
    }
    test_field_tag();
    fn test_field_retval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).retval) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_tag),
                "::",
                stringify!(retval)
            )
        );
    }
    test_field_retval();
    fn test_field_buf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buf) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_tag),
                "::",
                stringify!(buf)
            )
        );
    }
    test_field_buf();
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_tag),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
    fn test_field_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_tag),
                "::",
                stringify!(state)
            )
        );
    }
    test_field_state();
    fn test_field_lock_rec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lock_rec) as usize - ptr as usize
            },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_tag),
                "::",
                stringify!(lock_rec)
            )
        );
    }
    test_field_lock_rec();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_vm_protect_tag {
    pub prev: *mut rb_vm_protect_tag,
}
#[test]
fn bindgen_test_layout_rb_vm_protect_tag() {
    assert_eq!(
        ::std::mem::size_of::<rb_vm_protect_tag>(),
        8usize,
        concat!("Size of: ", stringify!(rb_vm_protect_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_vm_protect_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_vm_protect_tag))
    );
    fn test_field_prev() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_vm_protect_tag>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prev) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_vm_protect_tag),
                "::",
                stringify!(prev)
            )
        );
    }
    test_field_prev();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_unblock_callback {
    pub func: rb_unblock_function_t,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rb_unblock_callback() {
    assert_eq!(
        ::std::mem::size_of::<rb_unblock_callback>(),
        16usize,
        concat!("Size of: ", stringify!(rb_unblock_callback))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_unblock_callback>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_unblock_callback))
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_unblock_callback>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_unblock_callback),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_unblock_callback>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_unblock_callback),
                "::",
                stringify!(arg)
            )
        );
    }
    test_field_arg();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_mutex_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_ensure_entry {
    pub marker: VALUE,
    pub e_proc: ::std::option::Option<unsafe extern "C" fn(arg1: VALUE) -> VALUE>,
    pub data2: VALUE,
}
#[test]
fn bindgen_test_layout_rb_ensure_entry() {
    assert_eq!(
        ::std::mem::size_of::<rb_ensure_entry>(),
        24usize,
        concat!("Size of: ", stringify!(rb_ensure_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_ensure_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_ensure_entry))
    );
    fn test_field_marker() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_ensure_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).marker) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_ensure_entry),
                "::",
                stringify!(marker)
            )
        );
    }
    test_field_marker();
    fn test_field_e_proc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_ensure_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).e_proc) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_ensure_entry),
                "::",
                stringify!(e_proc)
            )
        );
    }
    test_field_e_proc();
    fn test_field_data2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_ensure_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data2) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_ensure_entry),
                "::",
                stringify!(data2)
            )
        );
    }
    test_field_data2();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_ensure_list {
    pub next: *mut rb_ensure_list,
    pub entry: rb_ensure_entry,
}
#[test]
fn bindgen_test_layout_rb_ensure_list() {
    assert_eq!(
        ::std::mem::size_of::<rb_ensure_list>(),
        32usize,
        concat!("Size of: ", stringify!(rb_ensure_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_ensure_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_ensure_list))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_ensure_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_ensure_list),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_entry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_ensure_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entry) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_ensure_list),
                "::",
                stringify!(entry)
            )
        );
    }
    test_field_entry();
}
pub type rb_ensure_list_t = rb_ensure_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_fiber_struct {
    _unused: [u8; 0],
}
pub type rb_fiber_t = rb_fiber_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_waiting_list {
    pub next: *mut rb_waiting_list,
    pub thread: *mut rb_thread_struct,
    pub fiber: *mut rb_fiber_struct,
}
#[test]
fn bindgen_test_layout_rb_waiting_list() {
    assert_eq!(
        ::std::mem::size_of::<rb_waiting_list>(),
        24usize,
        concat!("Size of: ", stringify!(rb_waiting_list))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_waiting_list>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_waiting_list))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_waiting_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_waiting_list),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_waiting_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_waiting_list),
                "::",
                stringify!(thread)
            )
        );
    }
    test_field_thread();
    fn test_field_fiber() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_waiting_list>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fiber) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_waiting_list),
                "::",
                stringify!(fiber)
            )
        );
    }
    test_field_fiber();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_execution_context_struct {
    pub vm_stack: *mut VALUE,
    pub vm_stack_size: size_t,
    pub cfp: *mut rb_control_frame_t,
    pub tag: *mut rb_vm_tag,
    pub protect_tag: *mut rb_vm_protect_tag,
    pub interrupt_flag: rb_atomic_t,
    pub interrupt_mask: rb_atomic_t,
    pub fiber_ptr: *mut rb_fiber_t,
    pub thread_ptr: *mut rb_thread_struct,
    pub local_storage: *mut rb_id_table,
    pub local_storage_recursive_hash: VALUE,
    pub local_storage_recursive_hash_for_trace: VALUE,
    pub root_lep: *const VALUE,
    pub root_svar: VALUE,
    pub ensure_list: *mut rb_ensure_list_t,
    pub trace_arg: *mut rb_trace_arg_struct,
    pub errinfo: VALUE,
    pub passed_block_handler: VALUE,
    pub raised_flag: u8,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub private_const_reference: VALUE,
    pub machine: rb_execution_context_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_execution_context_struct__bindgen_ty_1 {
    pub stack_start: *mut VALUE,
    pub stack_end: *mut VALUE,
    pub stack_maxsize: size_t,
    pub regs: jmp_buf,
}
#[test]
fn bindgen_test_layout_rb_execution_context_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_execution_context_struct__bindgen_ty_1>(),
        224usize,
        concat!(
            "Size of: ",
            stringify!(rb_execution_context_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_execution_context_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_execution_context_struct__bindgen_ty_1)
        )
    );
    fn test_field_stack_start() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_execution_context_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack_start) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct__bindgen_ty_1),
                "::",
                stringify!(stack_start)
            )
        );
    }
    test_field_stack_start();
    fn test_field_stack_end() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_execution_context_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack_end) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct__bindgen_ty_1),
                "::",
                stringify!(stack_end)
            )
        );
    }
    test_field_stack_end();
    fn test_field_stack_maxsize() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_execution_context_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stack_maxsize) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct__bindgen_ty_1),
                "::",
                stringify!(stack_maxsize)
            )
        );
    }
    test_field_stack_maxsize();
    fn test_field_regs() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_execution_context_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).regs) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct__bindgen_ty_1),
                "::",
                stringify!(regs)
            )
        );
    }
    test_field_regs();
}
#[test]
fn bindgen_test_layout_rb_execution_context_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_execution_context_struct>(),
        376usize,
        concat!("Size of: ", stringify!(rb_execution_context_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_execution_context_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_execution_context_struct))
    );
    fn test_field_vm_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vm_stack) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(vm_stack)
            )
        );
    }
    test_field_vm_stack();
    fn test_field_vm_stack_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vm_stack_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(vm_stack_size)
            )
        );
    }
    test_field_vm_stack_size();
    fn test_field_cfp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cfp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(cfp)
            )
        );
    }
    test_field_cfp();
    fn test_field_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(tag)
            )
        );
    }
    test_field_tag();
    fn test_field_protect_tag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).protect_tag) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(protect_tag)
            )
        );
    }
    test_field_protect_tag();
    fn test_field_interrupt_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interrupt_flag) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(interrupt_flag)
            )
        );
    }
    test_field_interrupt_flag();
    fn test_field_interrupt_mask() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interrupt_mask) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(interrupt_mask)
            )
        );
    }
    test_field_interrupt_mask();
    fn test_field_fiber_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fiber_ptr) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(fiber_ptr)
            )
        );
    }
    test_field_fiber_ptr();
    fn test_field_thread_ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_ptr) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(thread_ptr)
            )
        );
    }
    test_field_thread_ptr();
    fn test_field_local_storage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_storage) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(local_storage)
            )
        );
    }
    test_field_local_storage();
    fn test_field_local_storage_recursive_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_storage_recursive_hash) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(local_storage_recursive_hash)
            )
        );
    }
    test_field_local_storage_recursive_hash();
    fn test_field_local_storage_recursive_hash_for_trace() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_storage_recursive_hash_for_trace) as usize
                    - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(local_storage_recursive_hash_for_trace)
            )
        );
    }
    test_field_local_storage_recursive_hash_for_trace();
    fn test_field_root_lep() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_lep) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(root_lep)
            )
        );
    }
    test_field_root_lep();
    fn test_field_root_svar() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_svar) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(root_svar)
            )
        );
    }
    test_field_root_svar();
    fn test_field_ensure_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ensure_list) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(ensure_list)
            )
        );
    }
    test_field_ensure_list();
    fn test_field_trace_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).trace_arg) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(trace_arg)
            )
        );
    }
    test_field_trace_arg();
    fn test_field_errinfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).errinfo) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(errinfo)
            )
        );
    }
    test_field_errinfo();
    fn test_field_passed_block_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).passed_block_handler) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(passed_block_handler)
            )
        );
    }
    test_field_passed_block_handler();
    fn test_field_raised_flag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).raised_flag) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(raised_flag)
            )
        );
    }
    test_field_raised_flag();
    fn test_field_private_const_reference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).private_const_reference) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(private_const_reference)
            )
        );
    }
    test_field_private_const_reference();
    fn test_field_machine() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_execution_context_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).machine) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_execution_context_struct),
                "::",
                stringify!(machine)
            )
        );
    }
    test_field_machine();
}
impl rb_execution_context_struct {
    #[inline]
    pub fn method_missing_reason(&self) -> method_missing_reason {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_method_missing_reason(&mut self, val: method_missing_reason) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        method_missing_reason: method_missing_reason,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let method_missing_reason: u32 =
                unsafe { ::std::mem::transmute(method_missing_reason) };
            method_missing_reason as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rb_execution_context_t = rb_execution_context_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_ext_config {
    pub ractor_safe: bool,
}
#[test]
fn bindgen_test_layout_rb_ext_config() {
    assert_eq!(
        ::std::mem::size_of::<rb_ext_config>(),
        1usize,
        concat!("Size of: ", stringify!(rb_ext_config))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_ext_config>(),
        1usize,
        concat!("Alignment of ", stringify!(rb_ext_config))
    );
    fn test_field_ractor_safe() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_ext_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ractor_safe) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_ext_config),
                "::",
                stringify!(ractor_safe)
            )
        );
    }
    test_field_ractor_safe();
}
pub type rb_ractor_t = rb_ractor_struct;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rb_thread_struct {
    pub lt_node: list_node,
    pub self_: VALUE,
    pub ractor: *mut rb_ractor_t,
    pub vm: *mut rb_vm_t,
    pub ec: *mut rb_execution_context_t,
    pub last_status: VALUE,
    pub calling: *mut rb_calling_info,
    pub top_self: VALUE,
    pub top_wrapper: VALUE,
    pub thread_id: rb_nativethread_id_t,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub priority: i8,
    pub running_time_us: u32,
    pub native_thread_data: native_thread_data_t,
    pub blocking_region_buffer: *mut ::std::os::raw::c_void,
    pub thgroup: VALUE,
    pub value: VALUE,
    pub pending_interrupt_queue: VALUE,
    pub pending_interrupt_mask_stack: VALUE,
    pub interrupt_lock: rb_nativethread_lock_t,
    pub unblock: rb_unblock_callback,
    pub locking_mutex: VALUE,
    pub keeping_mutexes: *mut rb_mutex_struct,
    pub join_list: *mut rb_waiting_list,
    pub invoke_arg: rb_thread_struct__bindgen_ty_1,
    pub invoke_type: rb_thread_struct_thread_invoke_type,
    pub stat_insn_usage: VALUE,
    pub root_fiber: *mut rb_fiber_t,
    pub root_jmpbuf: rb_jmpbuf_t,
    pub scheduler: VALUE,
    pub blocking: ::std::os::raw::c_uint,
    pub name: VALUE,
    pub ext_config: rb_ext_config,
    pub altstack: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rb_thread_struct__bindgen_ty_1 {
    pub proc_: rb_thread_struct__bindgen_ty_1__bindgen_ty_1,
    pub func: rb_thread_struct__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_thread_struct__bindgen_ty_1__bindgen_ty_1 {
    pub proc_: VALUE,
    pub args: VALUE,
    pub kw_splat: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rb_thread_struct__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_thread_struct__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_thread_struct__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_proc() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_thread_struct__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proc_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(proc_)
            )
        );
    }
    test_field_proc();
    fn test_field_args() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_thread_struct__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(args)
            )
        );
    }
    test_field_args();
    fn test_field_kw_splat() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_thread_struct__bindgen_ty_1__bindgen_ty_1>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).kw_splat) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_1),
                "::",
                stringify!(kw_splat)
            )
        );
    }
    test_field_kw_splat();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_thread_struct__bindgen_ty_1__bindgen_ty_2 {
    pub func:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> VALUE>,
    pub arg: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_rb_thread_struct__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rb_thread_struct__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<rb_thread_struct__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_thread_struct__bindgen_ty_1__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
    fn test_field_arg() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<rb_thread_struct__bindgen_ty_1__bindgen_ty_2>::uninit(
                    );
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).arg) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct__bindgen_ty_1__bindgen_ty_2),
                "::",
                stringify!(arg)
            )
        );
    }
    test_field_arg();
}
#[test]
fn bindgen_test_layout_rb_thread_struct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rb_thread_struct__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(rb_thread_struct__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_thread_struct__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_thread_struct__bindgen_ty_1))
    );
    fn test_field_proc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).proc_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct__bindgen_ty_1),
                "::",
                stringify!(proc_)
            )
        );
    }
    test_field_proc();
    fn test_field_func() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).func) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct__bindgen_ty_1),
                "::",
                stringify!(func)
            )
        );
    }
    test_field_func();
}
impl ::std::fmt::Debug for rb_thread_struct__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "rb_thread_struct__bindgen_ty_1 {{ union }}")
    }
}
pub const rb_thread_struct_thread_invoke_type_thread_invoke_type_none:
    rb_thread_struct_thread_invoke_type = 0;
pub const rb_thread_struct_thread_invoke_type_thread_invoke_type_proc:
    rb_thread_struct_thread_invoke_type = 1;
pub const rb_thread_struct_thread_invoke_type_thread_invoke_type_ractor_proc:
    rb_thread_struct_thread_invoke_type = 2;
pub const rb_thread_struct_thread_invoke_type_thread_invoke_type_func:
    rb_thread_struct_thread_invoke_type = 3;
pub type rb_thread_struct_thread_invoke_type = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_rb_thread_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_thread_struct>(),
        568usize,
        concat!("Size of: ", stringify!(rb_thread_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_thread_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_thread_struct))
    );
    fn test_field_lt_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lt_node) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(lt_node)
            )
        );
    }
    test_field_lt_node();
    fn test_field_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(self_)
            )
        );
    }
    test_field_self();
    fn test_field_ractor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ractor) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(ractor)
            )
        );
    }
    test_field_ractor();
    fn test_field_vm() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).vm) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(vm)
            )
        );
    }
    test_field_vm();
    fn test_field_ec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ec) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(ec)
            )
        );
    }
    test_field_ec();
    fn test_field_last_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_status) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(last_status)
            )
        );
    }
    test_field_last_status();
    fn test_field_calling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).calling) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(calling)
            )
        );
    }
    test_field_calling();
    fn test_field_top_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top_self) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(top_self)
            )
        );
    }
    test_field_top_self();
    fn test_field_top_wrapper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top_wrapper) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(top_wrapper)
            )
        );
    }
    test_field_top_wrapper();
    fn test_field_thread_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thread_id) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(thread_id)
            )
        );
    }
    test_field_thread_id();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            89usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
    fn test_field_running_time_us() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).running_time_us) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(running_time_us)
            )
        );
    }
    test_field_running_time_us();
    fn test_field_native_thread_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).native_thread_data) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(native_thread_data)
            )
        );
    }
    test_field_native_thread_data();
    fn test_field_blocking_region_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blocking_region_buffer) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(blocking_region_buffer)
            )
        );
    }
    test_field_blocking_region_buffer();
    fn test_field_thgroup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thgroup) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(thgroup)
            )
        );
    }
    test_field_thgroup();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_pending_interrupt_queue() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pending_interrupt_queue) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(pending_interrupt_queue)
            )
        );
    }
    test_field_pending_interrupt_queue();
    fn test_field_pending_interrupt_mask_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pending_interrupt_mask_stack) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(pending_interrupt_mask_stack)
            )
        );
    }
    test_field_pending_interrupt_mask_stack();
    fn test_field_interrupt_lock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).interrupt_lock) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(interrupt_lock)
            )
        );
    }
    test_field_interrupt_lock();
    fn test_field_unblock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unblock) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(unblock)
            )
        );
    }
    test_field_unblock();
    fn test_field_locking_mutex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).locking_mutex) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(locking_mutex)
            )
        );
    }
    test_field_locking_mutex();
    fn test_field_keeping_mutexes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).keeping_mutexes) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(keeping_mutexes)
            )
        );
    }
    test_field_keeping_mutexes();
    fn test_field_join_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).join_list) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(join_list)
            )
        );
    }
    test_field_join_list();
    fn test_field_invoke_arg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).invoke_arg) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(invoke_arg)
            )
        );
    }
    test_field_invoke_arg();
    fn test_field_invoke_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).invoke_type) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(invoke_type)
            )
        );
    }
    test_field_invoke_type();
    fn test_field_stat_insn_usage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stat_insn_usage) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(stat_insn_usage)
            )
        );
    }
    test_field_stat_insn_usage();
    fn test_field_root_fiber() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_fiber) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(root_fiber)
            )
        );
    }
    test_field_root_fiber();
    fn test_field_root_jmpbuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_jmpbuf) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(root_jmpbuf)
            )
        );
    }
    test_field_root_jmpbuf();
    fn test_field_scheduler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scheduler) as usize - ptr as usize
            },
            528usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(scheduler)
            )
        );
    }
    test_field_scheduler();
    fn test_field_blocking() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).blocking) as usize - ptr as usize
            },
            536usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(blocking)
            )
        );
    }
    test_field_blocking();
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            544usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_ext_config() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ext_config) as usize - ptr as usize
            },
            552usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(ext_config)
            )
        );
    }
    test_field_ext_config();
    fn test_field_altstack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_thread_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).altstack) as usize - ptr as usize
            },
            560usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_thread_struct),
                "::",
                stringify!(altstack)
            )
        );
    }
    test_field_altstack();
}
impl ::std::fmt::Debug for rb_thread_struct {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write ! (f , "rb_thread_struct {{ lt_node: {:?}, self: {:?}, ractor: {:?}, vm: {:?}, ec: {:?}, last_status: {:?}, calling: {:?}, top_self: {:?}, top_wrapper: {:?}, thread_id: {:?}, status : {:?}, to_kill : {:?}, abort_on_exception : {:?}, report_on_exception : {:?}, pending_interrupt_queue_checked : {:?}, priority: {:?}, running_time_us: {:?}, native_thread_data: {:?}, blocking_region_buffer: {:?}, thgroup: {:?}, value: {:?}, pending_interrupt_queue: {:?}, pending_interrupt_mask_stack: {:?}, interrupt_lock: {:?}, unblock: {:?}, locking_mutex: {:?}, keeping_mutexes: {:?}, join_list: {:?}, invoke_arg: {:?}, invoke_type: {:?}, stat_insn_usage: {:?}, root_fiber: {:?}, root_jmpbuf: {:?}, scheduler: {:?}, blocking: {:?}, name: {:?}, ext_config: {:?}, altstack: {:?} }}" , self . lt_node , self . self_ , self . ractor , self . vm , self . ec , self . last_status , self . calling , self . top_self , self . top_wrapper , self . thread_id , self . status () , self . to_kill () , self . abort_on_exception () , self . report_on_exception () , self . pending_interrupt_queue_checked () , self . priority , self . running_time_us , self . native_thread_data , self . blocking_region_buffer , self . thgroup , self . value , self . pending_interrupt_queue , self . pending_interrupt_mask_stack , self . interrupt_lock , self . unblock , self . locking_mutex , self . keeping_mutexes , self . join_list , self . invoke_arg , self . invoke_type , self . stat_insn_usage , self . root_fiber , self . root_jmpbuf , self . scheduler , self . blocking , self . name , self . ext_config , self . altstack)
    }
}
impl rb_thread_struct {
    #[inline]
    pub fn status(&self) -> rb_thread_status {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_status(&mut self, val: rb_thread_status) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn to_kill(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_to_kill(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn abort_on_exception(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_abort_on_exception(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn report_on_exception(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_report_on_exception(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn pending_interrupt_queue_checked(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_pending_interrupt_queue_checked(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        status: rb_thread_status,
        to_kill: ::std::os::raw::c_uint,
        abort_on_exception: ::std::os::raw::c_uint,
        report_on_exception: ::std::os::raw::c_uint,
        pending_interrupt_queue_checked: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let status: u32 = unsafe { ::std::mem::transmute(status) };
            status as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let to_kill: u32 = unsafe { ::std::mem::transmute(to_kill) };
            to_kill as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let abort_on_exception: u32 = unsafe { ::std::mem::transmute(abort_on_exception) };
            abort_on_exception as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let report_on_exception: u32 = unsafe { ::std::mem::transmute(report_on_exception) };
            report_on_exception as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let pending_interrupt_queue_checked: u32 =
                unsafe { ::std::mem::transmute(pending_interrupt_queue_checked) };
            pending_interrupt_queue_checked as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type rb_thread_t = rb_thread_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_trace_arg_struct {
    pub event: rb_event_flag_t,
    pub ec: *mut rb_execution_context_t,
    pub cfp: *const rb_control_frame_t,
    pub self_: VALUE,
    pub id: ID,
    pub called_id: ID,
    pub klass: VALUE,
    pub data: VALUE,
    pub klass_solved: ::std::os::raw::c_int,
    pub lineno: ::std::os::raw::c_int,
    pub path: VALUE,
}
#[test]
fn bindgen_test_layout_rb_trace_arg_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_trace_arg_struct>(),
        80usize,
        concat!("Size of: ", stringify!(rb_trace_arg_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_trace_arg_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(rb_trace_arg_struct))
    );
    fn test_field_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).event) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(event)
            )
        );
    }
    test_field_event();
    fn test_field_ec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ec) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(ec)
            )
        );
    }
    test_field_ec();
    fn test_field_cfp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cfp) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(cfp)
            )
        );
    }
    test_field_cfp();
    fn test_field_self() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).self_) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(self_)
            )
        );
    }
    test_field_self();
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_called_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).called_id) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(called_id)
            )
        );
    }
    test_field_called_id();
    fn test_field_klass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).klass) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(klass)
            )
        );
    }
    test_field_klass();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
    fn test_field_klass_solved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).klass_solved) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(klass_solved)
            )
        );
    }
    test_field_klass_solved();
    fn test_field_lineno() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).lineno) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(lineno)
            )
        );
    }
    test_field_lineno();
    fn test_field_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_trace_arg_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_trace_arg_struct),
                "::",
                stringify!(path)
            )
        );
    }
    test_field_path();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_compile_data {
    pub err_info: VALUE,
    pub catch_table_ary: VALUE,
    pub start_label: *mut iseq_label_data,
    pub end_label: *mut iseq_label_data,
    pub redo_label: *mut iseq_label_data,
    pub current_block: *const rb_iseq_t,
    pub ensure_node_stack: *mut iseq_compile_data_ensure_node_stack,
    pub node: iseq_compile_data__bindgen_ty_1,
    pub insn: iseq_compile_data__bindgen_ty_2,
    pub loopval_popped: ::std::os::raw::c_int,
    pub last_line: ::std::os::raw::c_int,
    pub label_no: ::std::os::raw::c_int,
    pub node_level: ::std::os::raw::c_int,
    pub isolated_depth: ::std::os::raw::c_int,
    pub ci_index: ::std::os::raw::c_uint,
    pub option: *const rb_compile_option_t,
    pub ivar_cache_table: *mut rb_id_table,
    pub builtin_function_table: *const rb_builtin_function,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_compile_data__bindgen_ty_1 {
    pub storage_head: *mut iseq_compile_data_storage,
    pub storage_current: *mut iseq_compile_data_storage,
}
#[test]
fn bindgen_test_layout_iseq_compile_data__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<iseq_compile_data__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(iseq_compile_data__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_compile_data__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(iseq_compile_data__bindgen_ty_1))
    );
    fn test_field_storage_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storage_head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data__bindgen_ty_1),
                "::",
                stringify!(storage_head)
            )
        );
    }
    test_field_storage_head();
    fn test_field_storage_current() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storage_current) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data__bindgen_ty_1),
                "::",
                stringify!(storage_current)
            )
        );
    }
    test_field_storage_current();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_compile_data__bindgen_ty_2 {
    pub storage_head: *mut iseq_compile_data_storage,
    pub storage_current: *mut iseq_compile_data_storage,
}
#[test]
fn bindgen_test_layout_iseq_compile_data__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<iseq_compile_data__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(iseq_compile_data__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_compile_data__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(iseq_compile_data__bindgen_ty_2))
    );
    fn test_field_storage_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storage_head) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data__bindgen_ty_2),
                "::",
                stringify!(storage_head)
            )
        );
    }
    test_field_storage_head();
    fn test_field_storage_current() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).storage_current) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data__bindgen_ty_2),
                "::",
                stringify!(storage_current)
            )
        );
    }
    test_field_storage_current();
}
#[test]
fn bindgen_test_layout_iseq_compile_data() {
    assert_eq!(
        ::std::mem::size_of::<iseq_compile_data>(),
        136usize,
        concat!("Size of: ", stringify!(iseq_compile_data))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_compile_data>(),
        8usize,
        concat!("Alignment of ", stringify!(iseq_compile_data))
    );
    fn test_field_err_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).err_info) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(err_info)
            )
        );
    }
    test_field_err_info();
    fn test_field_catch_table_ary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).catch_table_ary) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(catch_table_ary)
            )
        );
    }
    test_field_catch_table_ary();
    fn test_field_start_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_label) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(start_label)
            )
        );
    }
    test_field_start_label();
    fn test_field_end_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end_label) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(end_label)
            )
        );
    }
    test_field_end_label();
    fn test_field_redo_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).redo_label) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(redo_label)
            )
        );
    }
    test_field_redo_label();
    fn test_field_current_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).current_block) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(current_block)
            )
        );
    }
    test_field_current_block();
    fn test_field_ensure_node_stack() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ensure_node_stack) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(ensure_node_stack)
            )
        );
    }
    test_field_ensure_node_stack();
    fn test_field_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(node)
            )
        );
    }
    test_field_node();
    fn test_field_insn() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).insn) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(insn)
            )
        );
    }
    test_field_insn();
    fn test_field_loopval_popped() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).loopval_popped) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(loopval_popped)
            )
        );
    }
    test_field_loopval_popped();
    fn test_field_last_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_line) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(last_line)
            )
        );
    }
    test_field_last_line();
    fn test_field_label_no() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).label_no) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(label_no)
            )
        );
    }
    test_field_label_no();
    fn test_field_node_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).node_level) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(node_level)
            )
        );
    }
    test_field_node_level();
    fn test_field_isolated_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).isolated_depth) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(isolated_depth)
            )
        );
    }
    test_field_isolated_depth();
    fn test_field_ci_index() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ci_index) as usize - ptr as usize
            },
            108usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(ci_index)
            )
        );
    }
    test_field_ci_index();
    fn test_field_option() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).option) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(option)
            )
        );
    }
    test_field_option();
    fn test_field_ivar_cache_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ivar_cache_table) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(ivar_cache_table)
            )
        );
    }
    test_field_ivar_cache_table();
    fn test_field_builtin_function_table() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).builtin_function_table) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data),
                "::",
                stringify!(builtin_function_table)
            )
        );
    }
    test_field_builtin_function_table();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_compile_option_struct {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub debug_level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rb_compile_option_struct() {
    assert_eq!(
        ::std::mem::size_of::<rb_compile_option_struct>(),
        8usize,
        concat!("Size of: ", stringify!(rb_compile_option_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<rb_compile_option_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(rb_compile_option_struct))
    );
    fn test_field_debug_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<rb_compile_option_struct>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).debug_level) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(rb_compile_option_struct),
                "::",
                stringify!(debug_level)
            )
        );
    }
    test_field_debug_level();
}
impl rb_compile_option_struct {
    #[inline]
    pub fn inline_const_cache(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_inline_const_cache(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn peephole_optimization(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_peephole_optimization(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn tailcall_optimization(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_tailcall_optimization(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn specialized_instruction(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_specialized_instruction(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn operands_unification(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_operands_unification(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn instructions_unification(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_instructions_unification(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn stack_caching(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_stack_caching(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn frozen_string_literal(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_frozen_string_literal(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn debug_frozen_string_literal(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_debug_frozen_string_literal(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn coverage_enabled(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_coverage_enabled(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        inline_const_cache: ::std::os::raw::c_uint,
        peephole_optimization: ::std::os::raw::c_uint,
        tailcall_optimization: ::std::os::raw::c_uint,
        specialized_instruction: ::std::os::raw::c_uint,
        operands_unification: ::std::os::raw::c_uint,
        instructions_unification: ::std::os::raw::c_uint,
        stack_caching: ::std::os::raw::c_uint,
        frozen_string_literal: ::std::os::raw::c_uint,
        debug_frozen_string_literal: ::std::os::raw::c_uint,
        coverage_enabled: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let inline_const_cache: u32 = unsafe { ::std::mem::transmute(inline_const_cache) };
            inline_const_cache as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let peephole_optimization: u32 =
                unsafe { ::std::mem::transmute(peephole_optimization) };
            peephole_optimization as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let tailcall_optimization: u32 =
                unsafe { ::std::mem::transmute(tailcall_optimization) };
            tailcall_optimization as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let specialized_instruction: u32 =
                unsafe { ::std::mem::transmute(specialized_instruction) };
            specialized_instruction as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let operands_unification: u32 = unsafe { ::std::mem::transmute(operands_unification) };
            operands_unification as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let instructions_unification: u32 =
                unsafe { ::std::mem::transmute(instructions_unification) };
            instructions_unification as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let stack_caching: u32 = unsafe { ::std::mem::transmute(stack_caching) };
            stack_caching as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let frozen_string_literal: u32 =
                unsafe { ::std::mem::transmute(frozen_string_literal) };
            frozen_string_literal as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let debug_frozen_string_literal: u32 =
                unsafe { ::std::mem::transmute(debug_frozen_string_literal) };
            debug_frozen_string_literal as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let coverage_enabled: u32 = unsafe { ::std::mem::transmute(coverage_enabled) };
            coverage_enabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_insn_info_entry {
    pub line_no: ::std::os::raw::c_int,
    pub events: rb_event_flag_t,
}
#[test]
fn bindgen_test_layout_iseq_insn_info_entry() {
    assert_eq!(
        ::std::mem::size_of::<iseq_insn_info_entry>(),
        8usize,
        concat!("Size of: ", stringify!(iseq_insn_info_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_insn_info_entry>(),
        4usize,
        concat!("Alignment of ", stringify!(iseq_insn_info_entry))
    );
    fn test_field_line_no() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_insn_info_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).line_no) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_insn_info_entry),
                "::",
                stringify!(line_no)
            )
        );
    }
    test_field_line_no();
    fn test_field_events() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_insn_info_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).events) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_insn_info_entry),
                "::",
                stringify!(events)
            )
        );
    }
    test_field_events();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_catch_table_entry {
    pub type_: iseq_catch_table_entry_catch_type,
    pub iseq: *mut rb_iseq_t,
    pub start: ::std::os::raw::c_uint,
    pub end: ::std::os::raw::c_uint,
    pub cont: ::std::os::raw::c_uint,
    pub sp: ::std::os::raw::c_uint,
}
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_RESCUE: iseq_catch_table_entry_catch_type =
    3;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_ENSURE: iseq_catch_table_entry_catch_type =
    5;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_RETRY: iseq_catch_table_entry_catch_type = 7;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_BREAK: iseq_catch_table_entry_catch_type = 9;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_REDO: iseq_catch_table_entry_catch_type = 11;
pub const iseq_catch_table_entry_catch_type_CATCH_TYPE_NEXT: iseq_catch_table_entry_catch_type = 13;
pub type iseq_catch_table_entry_catch_type = ::std::os::raw::c_uint;
#[test]
fn bindgen_test_layout_iseq_catch_table_entry() {
    assert_eq!(
        ::std::mem::size_of::<iseq_catch_table_entry>(),
        32usize,
        concat!("Size of: ", stringify!(iseq_catch_table_entry))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_catch_table_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(iseq_catch_table_entry))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_catch_table_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_catch_table_entry),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_iseq() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_catch_table_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).iseq) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_catch_table_entry),
                "::",
                stringify!(iseq)
            )
        );
    }
    test_field_iseq();
    fn test_field_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_catch_table_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_catch_table_entry),
                "::",
                stringify!(start)
            )
        );
    }
    test_field_start();
    fn test_field_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_catch_table_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_catch_table_entry),
                "::",
                stringify!(end)
            )
        );
    }
    test_field_end();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_catch_table_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_catch_table_entry),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_sp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_catch_table_entry>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sp) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_catch_table_entry),
                "::",
                stringify!(sp)
            )
        );
    }
    test_field_sp();
}
#[repr(C, packed)]
pub struct iseq_catch_table {
    pub size: ::std::os::raw::c_uint,
    pub entries: __IncompleteArrayField<iseq_catch_table_entry>,
}
#[test]
fn bindgen_test_layout_iseq_catch_table() {
    assert_eq!(
        ::std::mem::size_of::<iseq_catch_table>(),
        4usize,
        concat!("Size of: ", stringify!(iseq_catch_table))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_catch_table>(),
        1usize,
        concat!("Alignment of ", stringify!(iseq_catch_table))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_catch_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_catch_table),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_catch_table>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).entries) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_catch_table),
                "::",
                stringify!(entries)
            )
        );
    }
    test_field_entries();
}
#[repr(C)]
#[derive(Debug)]
pub struct iseq_compile_data_storage {
    pub next: *mut iseq_compile_data_storage,
    pub pos: ::std::os::raw::c_uint,
    pub size: ::std::os::raw::c_uint,
    pub buff: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_iseq_compile_data_storage() {
    assert_eq!(
        ::std::mem::size_of::<iseq_compile_data_storage>(),
        16usize,
        concat!("Size of: ", stringify!(iseq_compile_data_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<iseq_compile_data_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(iseq_compile_data_storage))
    );
    fn test_field_next() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data_storage),
                "::",
                stringify!(next)
            )
        );
    }
    test_field_next();
    fn test_field_pos() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pos) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data_storage),
                "::",
                stringify!(pos)
            )
        );
    }
    test_field_pos();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data_storage),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_buff() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<iseq_compile_data_storage>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buff) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(iseq_compile_data_storage),
                "::",
                stringify!(buff)
            )
        );
    }
    test_field_buff();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_iv_index_tbl_entry {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct succ_index_table {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_call_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_event_hook_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_ractor_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rb_postponed_job_struct {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_label_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iseq_compile_data_ensure_node_stack {
    pub _address: u8,
}
